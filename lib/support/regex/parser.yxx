/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */

/*
 *  Main authors:
 *     Jip J. Dekker <jip.dekker@monash.edu>
 */

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

%require "3.0"
%define api.prefix {regex_yy}

%code requires {
#include <gecode/minimodel.hh>

using namespace Gecode;

std::unique_ptr<REG> regex_from_string(const std::string& expression);
}

%{
#include <cstdlib>
#include <cstdio>

#include <gecode/minimodel.hh>
using namespace Gecode;

typedef struct yy_buffer_state *YY_BUFFER_STATE;
YY_BUFFER_STATE regex_yy_scan_string ( const char* yy_str );

extern int yylex();
extern FILE* yyin;

void yyerror(REG* regex, const char* s);
%}

%union {
    int iValue;
    REG* rValue;
}
%parse-param {REG* expr}

%token<iValue> R_INTEGER
%token R_GROUP_OPEN '('
%token R_GROUP_CLOSE ')'
%token R_STAR '*'
%token R_PLUS '+'
%token R_ANY '.'
%token R_SEP
%token R_UNION '|'

%type<rValue> regex expression term factor atom int_lit

%start regex

%%

regex:
  expression
  {
    *expr = (*$1);
    delete $1;
  }

expression:
    term
  | term R_UNION expression
    {
      *$1 = *$1 | *$3;
      delete $3;
      $$ = $1;
    }

term:
    factor
  | factor white_space term
    {
      *$1 = *$1 + *$3;
      delete $3;
      $$ = $1;
    }

factor:
    atom
  | atom R_STAR
    {
      *$1 = *(*$1);
      $$ = $1;
    }
  | atom R_PLUS
    {
      *$1 = +(*$1);
      $$ = $1;
    }

atom:
    int_lit
  | R_GROUP_OPEN expression R_GROUP_CLOSE
    { $$ = $2; }

int_lit:
    R_INTEGER
    { $$ = new REG($1); }

white_space:
    /* empty */
    | R_SEP white_space

%%

void yyerror(REG* regex, const char* s) {
    // TODO: Make this the correct exception
    throw std::runtime_error("Cannot parse regular expression: " + std::string(s));
}

std::unique_ptr<REG> regex_from_string(const std::string& regex_str) {
    REG* expr = new REG();
    regex_yy_scan_string(regex_str.c_str());
    int err = yyparse(expr);
    if (err != 0) {
        throw std::runtime_error("Cannot parse regular expression, error code " + std::to_string(err));
    }
    return std::unique_ptr<REG>(expr);
}
