# How to Test the `poem_macro` (for N00bs)

This document will guide you through the process of testing the `poem_macro` in this project. Don't worry if you're new to Rust or command-line tools â€“ we'll go step-by-step!

## What is a Macro?

In Rust, a macro is like a super-powered function that writes code for you. Instead of running at runtime, macros run *before* your code is compiled. They take some input and generate more Rust code, which then gets compiled along with the rest of your project.

The `poem_macro` is an "attribute macro," which means you use it by putting `#[poem_function]` right above a function definition. It's supposed to do something special to that function.

## The Test Setup

We have a special "test crate" (think of it as a mini-project just for testing this macro) called `poem_macro_test_crate`. This crate is designed to use the `poem_macro` and then try to compile the result.

You can find this test crate here: `/data/data/com.termux/files/home/storage/github/libminizinc/crates/poem_macro_test_crate`

Inside that folder, the main file is `src/lib.rs`, which looks something like this:

```rust
// crates/poem_macro_test_crate/src/lib.rs
use poem_macros::poem_function;
use anyhow::Result;
use std::collections::HashMap;

#[poem_function]
fn my_poem_function(
    _line: &str,
    _captures: Vec<String>,
    _fixed_fm: &mut HashMap<String, String>,
) -> Result<()> {
    Ok(())
}
```

The important part here is the `#[poem_function]` line. This is where we're telling the Rust compiler to apply our macro to `my_poem_function`.

## How to Run the Test

To run the test, you'll use a command in your terminal. This command tells Rust's build system (`cargo`) to try and compile and test our `poem_macro_test_crate`.

1.  **Open your terminal:** If you're using Termux on Android, open the Termux app.
2.  **Navigate to the project root:** You should already be in `/data/data/com.termux/files/home/storage/github/libminizinc`. If not, you can get there by typing:
    ```bash
    cd /data/data/com.termux/files/home/storage/github/libminizinc
    ```
3.  **Run the test command:** Type the following command and press Enter:
    ```bash
    cargo build --package poem_macro_test_crate > expanded_code_test.log 2>&1
    ```
    Let's break down this command:
    *   `cargo build`: This tells Rust's build system to try and build (compile) our code.
    *   `--package poem_macro_test_crate`: This specifies that we only want to build our special test crate, not the entire project (which can take a long time!).
    *   `> expanded_code_test.log`: This is a "redirection" command. It means "take all the normal output that would usually appear on my screen and put it into a file named `expanded_code_test.log` instead."
    *   `2>&1`: This is another redirection. It means "take all the *error* output (which normally goes to a different place called 'stderr') and send it to the same place as the normal output (which is `expanded_code_test.log`). So, both normal messages and errors will end up in our log file."

## How to Inspect the Output

After running the command, you won't see much on your screen, because all the output went into the `expanded_code_test.log` file.

1.  **View the log file:** To see what happened, you can use a command to display the contents of the file. Type:
    ```bash
    cat expanded_code_test.log
    ```
    This will print the entire content of the file to your terminal.

2.  **Understanding the Output:**
    You will likely see a lot of text. Don't be overwhelmed! Look for lines that start with `error:` or `warning:`. These are the important messages from the Rust compiler.

    You'll probably see errors similar to these:
    *   `error: expected one of :, ;, or =, found my_poem_function`
    *   `error: missing type for static item`

    These errors tell us that the code generated by our `poem_macro` is not valid Rust code. The compiler is confused by what the macro produced.

    The goal of fixing the macro is to run this command and see `Finished` messages without any `error:` lines!

## What's Next?

Once you've inspected the output, you'll have a clear picture of what's going wrong. The next step is to go back to the `poem_macro_impl` crate (where the macro's code lives) and try to fix the issues based on these error messages. This is where the real debugging fun begins!
