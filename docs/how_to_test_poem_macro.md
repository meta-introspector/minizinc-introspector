# How to Test the `poem_macro` (for N00bs)

This document will guide you through the process of testing the `poem_macro` in this project. Don't worry if you're new to Rust or command-line tools â€“ we'll go step-by-step!

## What is a Macro?

In Rust, a macro is like a super-powered function that writes code for you. Instead of running at runtime, macros run *before* your code is compiled. They take some input and generate more Rust code, which then gets compiled along with the rest of your project.

The `poem_macro` is an "attribute macro," which means you use it by putting `#[poem_function]` right above a function definition. It's supposed to do something special to that function.

## The Test Setup

We have a special "test crate" (think of it as a mini-project just for testing this macro) called `poem_macro_test_crate`. This crate is designed to use the `poem_macro` and then try to compile the result.

You can find this test crate here: `/data/data/com.termux/files/home/storage/github/libminizinc/crates/poem_macro_test_crate`

Inside that folder, the main file is `src/lib.rs`, which looks something like this:

```rust
// crates/poem_macro_test_crate/src/lib.rs
use poem_macros::poem_function;
use anyhow::Result;
use std::collections::HashMap;

#[poem_function]
fn my_poem_function(
    _line: &str,
    _captures: Vec<String>,
    _fixed_fm: &mut HashMap<String, String>,
) -> Result<()> {
    Ok(())
}
```

The important part here is the `#[poem_function]` line. This is where we're telling the Rust compiler to apply our macro to `my_poem_function`.

## How to Run the Test

To run the test, you'll use a command in your terminal. This command tells Rust's build system (`cargo`) to try and compile and test our `poem_macro_test_crate`.

1.  **Open your terminal:** If you're using Termux on Android, open the Termux app.
2.  **Navigate to the project root:** You should already be in `/data/data/com.termux/files/home/storage/github/libminizinc`. If not, you can get there by typing:
    ```bash
    cd /data/data/com.termux/files/home/storage/github/libminizinc
    ```
3.  **Run the test command:** Type the following command and press Enter:
    ```bash
    cargo build --package poem_macro_test_crate > expanded_code_test.log 2>&1
    ```
    Let's break down this command:
    *   `cargo build`: This tells Rust's build system to try and build (compile) our code.
    *   `--package poem_macro_test_crate`: This specifies that we only want to build our special test crate, not the entire project (which can take a long time!).
    *   `> expanded_code_test.log`: This is a "redirection" command. It means "take all the normal output that would usually appear on my screen and put it into a file named `expanded_code_test.log` instead."
    *   `2>&1`: This is another redirection. It means "take all the *error* output (which normally goes to a different place called 'stderr') and send it to the same place as the normal output (which is `expanded_code_test.log`). So, both normal messages and errors will end up in our log file."

## How to Inspect the Output

After running the command, you won't see much on your screen, because all the output went into the `expanded_code_test.log` file.

1.  **View the log file:** To see what happened, you can use a command to display the contents of the file. Type:
    ```bash
    cat expanded_code_test.log
    ```
    This will print the entire content of the file to your terminal.

2.  **Understanding the Output:**
    You will likely see a lot of text. Don't be overwhelmed! Look for lines that start with `error:` or `warning:`. These are the important messages from the Rust compiler.

    You'll probably see errors similar to these:
    *   `error: expected one of :, ;, or =, found my_poem_function`
    *   `error: missing type for static item`

    These errors tell us that the code generated by our `poem_macro` is not valid Rust code. The compiler is confused by what the macro produced.

    The goal of fixing the macro is to run this command and see `Finished` messages without any `error:` lines!

## Manually Reproducing the Bug (Advanced Debugging)

Sometimes, the compiler errors from a macro can be confusing. To get a clearer picture of what's going wrong, we can manually "expand" the macro and try to compile its output directly. This helps us see the exact code the macro is generating.

**Steps to Manually Reproduce the Bug:**

1.  **Identify the Macro's Input:**
    *   We used the `my_poem_function` from `crates/poem_macro_test_crate/src/lib.rs` as the input to our `poem_function` macro.

2.  **Understand the Macro's Generation Logic:**
    *   We looked at the `poem_function_impl` function in `crates/poem_macro_impl/src/lib.rs`. This function contains a `quote!` macro block that defines the structure of the code the macro generates.
    *   We identified placeholders like `#input_fn` (the original function), `#fn_name` (the name of the original function), and `#helper_fn_name` (a generated helper function name).

3.  **Manually Expand the Macro:**
    *   We took the `quote!` block and manually substituted the placeholders with their actual values from `my_poem_function`.
    *   For example, `#input_fn` became the full `my_poem_function` definition, `#fn_name` became `my_dummy_function`, and `#helper_fn_name` became `__get_fn_my_dummy_function`.

4.  **Create a File with the Expanded Code:**
    *   We created a new file: `crates/poem_macro_test_crate/src/generated_macro_output.rs`.
    *   We pasted the manually expanded code into this file.

5.  **Attempt to Compile the Expanded Code:**
    *   We modified `crates/poem_macro_test_crate/src/lib.rs` to include the `generated_macro_output.rs` module and added a simple test function that would attempt to compile it.
    *   We then ran `cargo build --package poem_macro_test_crate`.

**Observation:**

When we tried to compile the `generated_macro_output.rs` file, we observed the same compilation errors as when the macro was applied directly:

*   `error: expected one of :, ;, or =, found my_dummy_function`
*   `error: missing type for static item`

This confirmed that the bug was indeed in the code generated by the macro, and not in how the macro was being applied. This manual expansion process allowed us to pinpoint the exact syntax errors within the generated code, specifically related to the `static` declaration and the `stringify!` macro usage.

## The Fix and Verification

We identified that the primary issue was the `static` declaration within the macro's generated code. Specifically, the `stringify!` macro was being generated with spaces around the exclamation mark (e.g., `stringify !`), which is invalid Rust syntax. Additionally, the generated code was missing necessary `use` statements for `anyhow::Result` and `std::collections::HashMap`.

To fix this, we performed the following steps in `crates/poem_macro_impl/src/lib.rs`:

1.  **Added `use` statements:** We ensured that `use anyhow::Result;` and `use std::collections::HashMap;` were included in the `quote!` block, so they are present in the generated code.
2.  **Corrected `stringify!` usage:** We removed the spaces around the exclamation mark in `stringify!`, changing `stringify ! ( #fn_name )` to `stringify!(#fn_name)`.
3.  **Ensured `PoemFnPtr` alias is used and defined:** We made sure the `PoemFnPtr` type alias was uncommented and used in the `static` declaration.

After applying these fixes, we updated the `poem_macro_impl_test` to directly compile the generated code in a temporary `cargo` project. Running `cargo run --package poem_macro_impl_test` now shows:

```
Generated code compiled successfully!
```

This confirms that the `poem_macro` is now generating valid Rust code that compiles without errors. This is a significant milestone!