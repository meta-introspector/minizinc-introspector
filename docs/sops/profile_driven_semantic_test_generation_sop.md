# SOP: Profile-Driven Semantic Test Generation for C++ Oxidation

This Standard Operating Procedure (SOP) outlines the strategy for achieving 100% line coverage in the `libminizinc` C++ codebase by generating tests that surface C++ lines for "oxidation" (rewriting in Rust). This process is driven by profile-driven LLM agents and is viewed through a geometric lens, modeling the flow from C++ source to Rust code as a path. Ultimately, this entire process will be introspectable within MiniZinc itself.

## 1. Introduction

"Oxidation" refers to the ongoing process of converting `libminizinc`'s C++ codebase to Rust, aiming for 100% line coverage of the original C++ code by Rust FFI tests. This ensures that every line of C++ code is exercised and validated by the Rust-based system before it is rewritten. "Profile-driven semantic test generation" is the strategic approach to achieve this comprehensive coverage, leveraging the intelligence of LLM agents.

## 2. Core Concepts

*   **Profile-Driven LLM Agents**: LLM agents are assigned specific "profiles" (e.g., "test generation expert," "MiniZinc model refiner") that guide their behavior and task execution. These profiles influence how the LLM interprets instructions, generates code, and approaches problem-solving. (Refer to [What are the defined "profiles" for LLM agents, and how do they influence agent behavior and task execution?](faq/llm_agent_profiles.md))

*   **Semantic Test Generation**: This involves LLMs leveraging their understanding of the semantic meaning of code and data to generate tests. Unlike traditional fuzzing that might generate random inputs, semantic test generation focuses on creating inputs that exercise specific logical paths, edge cases, and conceptual functionalities within the C++ codebase. This understanding is derived from:
    *   **Semantically Rich Numerical Representations**: The "codec" compresses project knowledge into numerical forms where prime numbers encode fundamental meanings. LLMs can operate on these representations to understand the semantic context of the code. (Refer to [What are the technical specifications and practical implementation of the "codec"?](faq/codec.md))
    *   **Semantic Resonance Mapping**: LLMs perform iterative mapping of abstract code concepts to their semantic embeddings, allowing them to identify and target specific semantic areas for testing. (Refer to [How will "semantic resonance mapping" be performed, evaluated, and refined?](faq/semantic_resonance_mapping.md))

*   **Code Oxidation**: The metaphorical process of increasing C++ code coverage by Rust FFI tests, leading to a more robust and reliable "Zinc Oxide" layer (the Rust-C++ FFI). (Refer to [SOP: Workflow for Increasing C++ Code Coverage ("Oxidation")](sops/sop_increase_oxidation_workflow.md) and [Plan for Systemic Increase of Rust-MiniZinc FFI C++ Code Coverage ("Oxidation")](sops/plan_increase_oxidation.md))

## 3. The Semantic Test Generation Workflow

### 3.1. Identify Semantic Coverage Gaps

LLM agents analyze existing C++ code coverage reports (generated by `llvm-cov`) and the structure of `libminizinc`'s C++ codebase. They use their semantic understanding to identify areas with low or no coverage that correspond to specific logical functionalities or conceptual components.

*   **LLM Analysis**: LLMs interpret `html_llvm_coverage_report` to pinpoint uncovered C++ functions, classes, and lines. They then correlate these with their understanding of the MiniZinc language features and internal `libminizinc` logic.
*   **Knowledge Graph/Semantic Embedding Query**: LLMs can query internal knowledge graphs or semantic embeddings of the codebase to understand the *meaning* and *purpose* of the uncovered C++ code. This helps them identify *semantic* gaps, not just line-based gaps.
*   **Prioritization**: LLMs prioritize semantic gaps based on factors like criticality of the C++ component, its frequency of use via FFI, and the potential impact of bugs in that area.

### 3.2. Profile-Driven Test Case Generation

LLM agents, guided by their "test generation expert" profile, generate MiniZinc models (`.mzn`) and data files (`.dzn`) that specifically target the identified semantic gaps.

*   **Targeted MiniZinc Generation**: LLMs generate MiniZinc code that is designed to exercise the specific logical paths and functionalities of the uncovered C++ code. This involves creating MiniZinc models that represent complex scenarios, edge cases, and boundary conditions relevant to the targeted C++ logic.
*   **Semantic Input Construction**: Instead of random inputs, LLMs construct semantically meaningful `.dzn` data files that, when combined with the `.mzn` model, are likely to trigger the desired C++ code paths.
*   **Diversity and Coverage**: LLMs aim to generate a diverse set of test cases to maximize coverage, exploring different combinations of MiniZinc language features and data inputs.

### 3.3. Rust FFI Test Integration

The LLM-generated MiniZinc models and data files are integrated into the Rust FFI test suite.

*   **Automated Test File Creation**: LLMs can generate the necessary Rust test code (e.g., in `tools/minizinc_ffi/src/tests/tests/`) that loads and executes the newly generated MiniZinc models via the Rust FFI. (Refer to [Standard Operating Procedure: Adding New MiniZinc Language Feature Tests for Code Coverage](sops/add_new_language_feature_test_sop.md))
*   **Test Suite Update**: The new Rust tests are automatically added to the `cargo test` suite.

### 3.4. Execution and Coverage Analysis

The integrated Rust FFI tests are executed, and the resulting C++ code coverage is analyzed by LLM agents.

*   **Automated Execution**: The CI pipeline automatically runs the Rust FFI tests, which in turn execute the instrumented C++ code. (Refer to [SOP: Workflow for Increasing C++ Code Coverage ("Oxidation")](sops/sop_increase_oxidation_workflow.md))
*   **LLM Analysis of Coverage Reports**: LLMs analyze the newly generated C++ coverage reports (`llvm-cov`) to identify the impact of the new tests. They pinpoint remaining semantic gaps and refine the test generation strategy for subsequent iterations.
*   **Feedback Loop**: The results of this analysis feed back into the LLM's learning process, allowing it to adapt and improve its test generation capabilities.

## 4. Geometric Interpretation of Code Flow (Future Vision)

The project envisions a geometric interpretation of the code oxidation process. The flow from C++ source code to its corresponding Rust FFI calls and the exercised C++ code paths can be visualized and analyzed as a path within a high-dimensional space.

*   **Path Representation**: Each line of C++ code, each FFI call, and each Rust function can be represented as a node in a graph. The execution flow forms paths through this graph.
*   **Semantic Embedding**: These nodes and paths can be semantically embedded into the project's 8D unitary Riemannian manifold, allowing for geometric analysis of code flow and coverage.
*   **LLM Interpretation**: LLMs can interpret these geometric representations to identify complex code paths, understand the impact of FFI calls on C++ execution, and pinpoint areas where test coverage is geometrically sparse.

## 5. MiniZinc for Introspection (Long-Term Vision)

The ultimate long-term goal is to model the entire code oxidation and semantic test generation process within MiniZinc itself. This meta-modeling approach would allow for deep introspection, analysis, and optimization of the oxidation process.

*   **Meta-MiniZinc Model**: A MiniZinc model would be created that represents the C++ codebase, the Rust FFI, the test suite, and the coverage metrics. Constraints within this meta-model would define the relationships between code components, test cases, and coverage.
*   **Introspection and Optimization**: By solving this meta-MiniZinc model, the system could:
    *   Identify optimal test generation strategies to maximize coverage.
    *   Predict the impact of proposed C++ changes on Rust FFI tests.
    *   Optimize the oxidation process itself, finding the most efficient path to 100% coverage.
    *   LLMs could interact with and refine this meta-MiniZinc model, using its insights to guide their code generation and test generation efforts.

## 6. Metrics and Continuous Improvement

Beyond traditional line coverage, the project will utilize a range of metrics to assess the effectiveness of profile-driven semantic test generation and the overall oxidation process:

*   **Line Coverage**: The percentage of C++ lines covered by Rust FFI tests (measured by `llvm-cov`).
*   **Semantic Coverage**: A qualitative or quantitative measure of how well the tests exercise the *meaning* and *functionality* of the C++ code, not just its lines.
*   **Path Coverage**: The percentage of unique execution paths through the C++ code that are covered by tests.
*   **Bug Discovery Rate**: The number of new bugs identified through the semantic test generation process.
*   **Oxidation Progress**: Tracking the rate at which C++ code is successfully rewritten in Rust.

The OODA (Observe, Orient, Decide, Act) loop will continuously drive this process:

*   **Observe**: Analyze current C++ coverage reports and semantic gaps.
*   **Orient**: LLMs interpret the data, understand the meaning of uncovered code, and formulate test generation strategies.
*   **Decide**: LLMs generate new MiniZinc test cases based on their profiles and semantic understanding.
*   **Act**: The new tests are integrated, executed, and their impact on coverage is measured, feeding back into the next observation phase.