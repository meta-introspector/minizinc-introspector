# SOP: Advanced Testing, Coverage, and Profiling for Rust-MiniZinc FFI Projects (v2)

## 1. Purpose
This Standard Operating Procedure (SOP) guides new developers on advanced testing, code coverage, and profiling techniques for Rust-MiniZinc Foreign Function Interface (FFI) projects. It emphasizes how Rust tests interact with and provide coverage for the underlying C++ MiniZinc library.

## 2. Scope
This SOP applies to testing, coverage analysis, and profiling within the `libminizinc` project, specifically focusing on the `minizinc_ffi` Rust crate and its interaction with the C++ MiniZinc library.

## 3. Prerequisites
Before you begin, ensure you are familiar with:
*   Basic Rust and C++ development.
*   The "SOP: Rust FFI Development and 'One Declaration Per File' Refactoring" document.
*   The "Architecture: Refactoring the MiniZinc Parser" document for understanding the parser's structure.

## 4. Code Coverage Fundamentals (Rust)

### 4.1. Why Coverage?
Code coverage measures the percentage of your codebase executed by your tests. High coverage indicates that more of your code is being exercised, reducing the likelihood of undetected bugs and improving confidence in your software's reliability.

### 4.2. Using `cargo tarpaulin`
`cargo tarpaulin` is a popular tool for generating code coverage reports for Rust projects.

**Installation:**
If you haven't already, install `cargo tarpaulin` by running:
```bash
cargo install cargo-tarpaulin
```

**Basic Usage:**
To generate a coverage report for the `minizinc_ffi` crate, including its tests, navigate to the project root (`/data/data/com.termux/files/home/storage/github/libminizinc/`) and run:
```bash
cargo tarpaulin --package minizinc_ffi --tests
```

**Interpreting Reports:**
The output will show a summary of covered and uncovered lines, typically broken down by file. A detailed HTML report is usually generated in the `target/tarpaulin/` directory.

### 4.3. Achieving High Coverage

*   **Unit Tests:** Write tests that focus on individual functions, methods, or small logical units. These should be fast and isolated.
*   **Integration Tests:** Test how different modules or components interact with each other. For FFI projects, this includes testing how your Rust FFI wrappers interact with the C++ functions.
*   **Edge Cases and Error Handling:** Explicitly write tests for unusual inputs, boundary conditions, and all possible error paths. This is crucial for robust FFI wrappers.
*   **Mocking/Faking (for FFI):** For complex C++ dependencies, consider mocking or faking C++ functions in your Rust unit tests. This allows you to test your Rust FFI logic in isolation without needing to compile and link the entire C++ library for every unit test.

## 5. Profiling C/C++ Code (Called by Rust FFI)
Profiling helps identify performance bottlenecks in your code. When working with FFI, it's essential to profile both the Rust and C++ sides.

**Tools:**
*   **`gprof` (GNU Profiler):** A basic profiler for C/C++ code. Requires compiling your C++ code with `-pg` flag.
*   **`perf` (Linux performance events):** A powerful, system-wide profiling tool available on Linux.
*   **Valgrind (Callgrind):** A memory debugging and profiling tool that can generate call graphs and cache usage information.

**Workflow (General):**
1.  **Compile C++ with Profiling Flags:** Modify your CMake build (e.g., in `CMakeLists.txt` or specific `*.cmake` files) to include profiling flags (e.g., `-pg` for `gprof`, or flags for `gcov`/`lcov` for coverage-based profiling).
2.  **Run Rust Tests:** Execute your Rust tests (`cargo test`). This will trigger the FFI calls and execute the profiled C++ code.
3.  **Process Profiling Data:** Use the profiling tool's utilities to analyze the generated data (e.g., `gprof <executable> gmon.out` for `gprof`).

## 6. Cross-Language Coverage Analysis (Rust covering MiniZinc C++)
Demonstrating that your Rust tests effectively cover the underlying MiniZinc C++ code is key to ensuring the FFI's reliability.

**Methodology:**
1.  **Compile C++ with Coverage Flags:** Modify your C++ build system (CMake) to compile the MiniZinc C++ library and your FFI wrapper with coverage instrumentation flags (e.g., `-fprofile-arcs -ftest-coverage` for GCC/Clang).
2.  **Run Rust Tests:** Execute your Rust tests (`cargo test`). This will run the instrumented C++ code.
3.  **Process C++ Coverage Data:** Use C++ coverage tools (like `gcov` and `lcov`) to process the `.gcda` and `.gcno` files generated by the instrumented C++ code. These tools will generate reports showing which lines of C++ code were executed.
4.  **Interpret Results:** Analyze the C++ coverage reports to see which parts of the MiniZinc C++ library are being exercised by your Rust tests. While direct mapping of Rust test cases to specific C++ lines can be challenging, this provides valuable insight into the FFI's effectiveness.

## 7. Addressing the `isModelString` Corruption Bug

During development, a subtle bug was identified where the `isModelString` boolean flag within MiniZinc's `ParseWorkItem` struct (in `lib/parser.cpp`) was being corrupted or misread, particularly on AArch64 Android. This led to the MiniZinc parser incorrectly attempting file I/O when parsing a model from a string, resulting in a "Cannot open file ''" error.

**Workaround Implemented:**

To address this issue without modifying the vendored MiniZinc source code, a workaround has been implemented:

*   **New FFI Function (`minizinc_parse_model_with_flags`)**: A new C++ FFI function was introduced that explicitly takes a boolean flag (`is_model_string`) indicating whether the model content is from a string.
*   **Repurposing `isFlatZinc`**: This `is_model_string` flag is passed to the `parse` function in `lib/parser.cpp` by repurposing the `isFlatZinc` argument. This argument was chosen because it was consistently `false` in the string parsing scenario and its original purpose was not critical for this specific code path.
*   **Rust Side Changes**: The Rust FFI bindings and environment wrapper were updated to use this new FFI function and pass `true` for `is_model_string` when parsing from a string. Additionally, a dummy filename (e.g., "dummy_model.mzn") is now passed from the Rust side to prevent MiniZinc from attempting to open an empty file.

**Impact:** This workaround ensures that the MiniZinc parser correctly identifies string-based models, preventing the erroneous file open attempts. The underlying memory corruption issue with `ParseWorkItem::isModelString` is still present in the vendored MiniZinc library but is bypassed by this explicit flag.

## 8. Reporting and Interpretation

*   **Combine Reports:** Consider tools or custom scripts to combine Rust and C++ coverage reports for a holistic view.
*   **Visualize Data:** Use graphical tools (e.g., HTML reports from `tarpaulin` and `lcov`) to visualize coverage and profiling data.
*   **Iterate:** Use the insights from coverage and profiling to identify areas for more testing or performance optimization.

## 9. Continuous Integration

Integrate these testing, coverage, and profiling steps into your Continuous Integration (CI) pipeline to ensure ongoing code quality and performance monitoring.
