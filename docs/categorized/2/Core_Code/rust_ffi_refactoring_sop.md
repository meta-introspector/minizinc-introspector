# SOP: Rust FFI Development and "One Declaration Per File" Refactoring

## 1. Purpose
This Standard Operating Procedure (SOP) guides new developers through the process of developing and refactoring the Rust Foreign Function Interface (FFI) within the `libminizinc` project, specifically adhering to the "one declaration per file" pattern.

## 2. Scope
This SOP applies to all Rust FFI development in the `libminizinc` project, particularly within the `tools/minizinc_ffi/` crate.

## 3. Prerequisites
Before you begin, ensure you have a solid understanding of:
*   Rust programming language fundamentals.
*   Cargo build system.
*   C++ programming language basics.
*   CMake build system.
*   MiniZinc basics.
*   Foreign Function Interface (FFI) concepts.

## 4. Core Principles: "One Declaration Per File"
To enhance modularity, readability, and maintainability, and to simplify debugging, we adhere to the "one declaration per file" principle. This means:
*   Each `pub struct`, `pub enum`, `pub fn`, `impl` block, or `unsafe extern "C"` block should reside in its own dedicated `.rs` file.
*   `lib.rs` and `mod.rs` files should *only* contain `pub mod` and `pub use` statements to declare and re-export submodules.

## 5. Rust FFI Setup

### 5.1. `ffi_bindings.rs`
This file declares the C functions that the Rust code will call. It contains an `unsafe extern "C"` block with `pub fn` declarations for each C function.

**Example (`tools/minizinc_ffi/src/ffi_bindings.rs`):**
```rust
use std::os::raw::c_char;
use crate::types::MznSolver;

unsafe extern "C" {
    pub fn minizinc_env_new() -> *mut MznSolver;
    pub fn minizinc_get_version_string() -> *const c_char;
    // ... other FFI function declarations
}
```

### 5.2. `build.rs`
This script tells Cargo how to link against the compiled C++ MiniZinc library. It specifies the library search paths and the libraries to link.

**Example (`tools/minizinc_ffi/build.rs`):**
```rust
fn main() {
    println!("cargo:rustc-link-search=/data/data/com.termux/files/home/storage/github/libminizinc/build");
    println!("cargo:rustc-link-search=/data/data/com.termux/files/home/storage/github/libminizinc/install/lib");
    println!("cargo:rustc-link-lib=dylib=minizinc_c_wrapper");
    println!("cargo:rustc-link-lib=dylib=mzn");
    // Set rpath for runtime linking
    println!("cargo:rustc-link-arg=-Wl,-rpath,/data/data/com.termux/files/home/storage/github/libminizinc/build");
    println!("cargo:rustc-link-arg=-Wl,-rpath,/data/data/com.termux/files/home/storage/github/libminizinc/install/lib");
}
```

### 5.3. `Cargo.toml`
The `Cargo.toml` file needs to specify that a build script is used and declare the native library it links against.

**Example (`tools/minizinc_ffi/Cargo.toml`):**
```toml
[package]
name = "minizinc_ffi"
version = "0.1.0"
edition = "2024"
build = "build.rs"
links = "minizinc_c_wrapper"

[dependencies]
```

## 6. Refactoring an Existing `lib.rs` (Step-by-Step Guide)

Follow these steps to refactor a monolithic `lib.rs` file into smaller, modular components:

1.  **Identify Declarations:** Open `tools/minizinc_ffi/src/lib.rs`. Identify all `pub struct`, `pub enum`, `impl` blocks, and `unsafe extern "C"` blocks.

2.  **Create New Files:** For each identified declaration or `impl` block, create a new `.rs` file in the `tools/minizinc_ffi/src/` directory (or a new subdirectory if logical grouping is needed, e.g., `tools/minizinc_ffi/src/expression_impls/`).
    *   **Naming Convention:** Use descriptive names, typically `lowercase_snake_case.rs` for files containing a single declaration or `impl` block (e.g., `my_struct.rs`, `my_struct_impl.rs`).
    *   **For `unsafe extern "C"` block:** Create `tools/minizinc_ffi/src/ffi_bindings.rs`.
    *   **For `#[cfg(test)] mod tests` block:** Create `tools/minizinc_ffi/src/tests/mod.rs` (and create `tools/minizinc_ffi/src/tests/` directory if it doesn't exist).

3.  **Move Content:** Cut the content of the declaration or `impl` block from `lib.rs` and paste it into its new file.

4.  **Update `lib.rs`:** In `tools/minizinc_ffi/src/lib.rs`, replace the moved content with appropriate `pub mod` and `pub use` statements. The `lib.rs` file should eventually only contain these statements.

    **Script Assistance (`scripts/editor/generate_pub_uses.sh`):**
    You can use the following bash script to assist in generating `pub mod` and `pub use` statements for `lib.rs` based on the file structure. Ensure the script has execute permissions (`chmod +x scripts/editor/generate_pub_uses.sh`).

    ```bash
    #!/bin/bash

    # This script generates pub use statements for lib.rs based on the file structure.
    # It should be run from the project root.

    LIB_RS_DIR="tools/minizinc_ffi/src"

    echo "// Generated by generate_pub_uses.sh - DO NOT EDIT MANUALLY"
    echo ""

    # Find all .rs files directly under LIB_RS_DIR, excluding lib.rs
    find "$LIB_RS_DIR" -maxdepth 1 -type f -name "*.rs" ! -name "lib.rs" | sort | while read -r file; do
        module_name=$(basename "$file" .rs)
        echo "pub mod ${module_name};"
        echo "pub use ${module_name}::*;"
        echo ""
done

    # Find all subdirectories under LIB_RS_DIR, excluding feature_tests
    find "$LIB_RS_DIR" -maxdepth 1 -type d ! -name "$(basename "$LIB_RS_DIR")" ! -name "feature_tests" | sort | while read -r dir; do
        module_name=$(basename "$dir")
        echo "pub mod ${module_name};"
        echo "pub use ${module_name}::*;"
        echo ""
    done
    ```

    **Usage:**
    1.  Run the script from the project root: `./scripts/editor/generate_pub_uses.sh > tools/minizinc_ffi/src/lib.rs.new`
    2.  Review `lib.rs.new` and manually merge it into `tools/minizinc_ffi/src/lib.rs`, adding necessary `use` statements at the top.

5.  **Update Imports in Other Files:** For any file that uses declarations moved from `lib.rs` or FFI functions, update its `use` statements.
    *   For types (e.g., `MiniZincModel`, `MiniZincExpression`), use `use crate::types::{TypeName};`.
    *   For FFI functions, use `use crate::ffi_bindings::{function_name};`.

6.  **Iterative Build and Test:** After each significant move or change, attempt to build the project (`cargo build`) to catch any errors early. This iterative approach simplifies debugging.

## 7. Troubleshooting Common Issues

*   **`error[E0432]: unresolved import ...`:**
    *   **Cause:** The Rust compiler cannot find the specified module or item.
    *   **Solution:** Ensure the module is declared with `pub mod` in its parent `mod.rs` or `lib.rs`. Verify the `use` path is correct (e.g., `crate::module::Item`).

*   **`error[E0425]: cannot find function ... in module ffi_bindings`:**
    *   **Cause:** The Rust compiler cannot find the declaration of the C function.
    *   **Solution:** Ensure the function is declared with `pub fn` within the `unsafe extern "C"` block in `ffi_bindings.rs`. Verify the `use` statement in the calling file is correct.

*   **`error[E0255]: the name ... is defined multiple times`:**
    *   **Cause:** A `pub struct` or `impl` block is defined in multiple places.
    *   **Solution:** Adhere strictly to the "one declaration per file" principle. Ensure `pub struct` declarations are only in `types/mod.rs` and `impl` blocks are in their dedicated `_impl.rs` files.

*   **`CANNOT LINK EXECUTABLE ... library "libminizinc_c_wrapper.so" not found` (runtime linking error):**
    *   **Cause:** The Rust executable cannot find the shared C++ library at runtime.
    *   **Solution:** Ensure `build.rs` correctly specifies `cargo:rustc-link-arg=-Wl,-rpath,...` for the library paths.

*   **C++ Compilation Errors (during `reproduce_minizinc_ffi_bug.sh`):**
    *   **Cause:** Issues in the C++ FFI wrapper code or incorrect MiniZinc API usage.
    *   **Solution:** Examine the specific C++ error messages. Consult the original MiniZinc source code (`lib/` directory) and MiniZinc C++ API documentation to understand correct usage. Ensure all necessary C++ headers are included in the FFI `.cpp` files (e.g., `minizinc/ast.hh` for `TypeInst`).

## 8. Verification

After making changes, always verify your work:

1.  **Build the project:** Run `cargo build` from the `tools/minizinc_ffi/` directory.
2.  **Run tests:** Execute `cargo test --package minizinc_ffi` from the project root. Ensure all tests pass.

This SOP will be updated as new patterns emerge or issues are resolved.
