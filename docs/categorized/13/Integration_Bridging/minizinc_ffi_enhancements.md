# MiniZinc FFI Enhancements: Extracting More Value into Rust

This document outlines proposed enhancements to the Rust Foreign Function Interface (FFI) for MiniZinc, aiming to unlock more of MiniZinc's capabilities within the Rust ecosystem and maximize its utility.

The current FFI primarily focuses on parsing MiniZinc models and basic inspection of the Abstract Syntax Tree (AST). To truly leverage MiniZinc's power, we need to expose its core functionality: solving constraint models and retrieving solutions.

## 1. Core Value: Solving and Solution Retrieval

**Current Limitation:** The FFI can parse models but cannot solve them or retrieve solutions. This is the most significant missing piece.

**Proposed C++ FFI Additions (`minizinc_ffi_declarations.h` and new `.cpp` implementations):**

*   **`minizinc_solve_model(MiniZinc::MznSolver* solver, MiniZincModel* model) -> int`**:
    Initiates the solving process for a given model. Returns 0 on success, non-zero on error or if no solution is found.

*   **`minizinc_has_solution(MiniZinc::MznSolver* solver) -> bool`**:
    Checks if the solver found at least one solution.

*   **`minizinc_next_solution(MiniZinc::MznSolver* solver) -> bool`**:
    Advances to the next solution if multiple solutions exist. Returns `true` if a new solution is available, `false` otherwise.

*   **`minizinc_get_solution_variable_value_int(MiniZinc::MznSolver* solver, const char* var_name, int* value) -> bool`**:
    Retrieves the integer value of a specified variable from the current solution. (Similar functions would be needed for `float`, `bool`, `set`, `string`, and `array` types).

**Proposed Rust FFI Additions (`lib.rs`):**

*   **`MiniZincEnvironment` methods:**
    ```rust
    impl MiniZincEnvironment {
        pub fn solve_model(&self, model: &MiniZincModel) -> Result<(), String> { /* ... */ }
        pub fn has_solution(&self) -> bool { /* ... */ }
        pub fn next_solution(&self) -> bool { /* ... */ }
        pub fn get_solution_variable_int(&self, var_name: &str) -> Result<i32, String> { /* ... */ }
        // ... similar methods for float, bool, set, string
    }
    ```

**Value Extraction ("Zinc Oxide"):** This is the most critical step. By enabling solving and solution retrieval, Rust applications can directly leverage MiniZinc for:
    *   **Optimization and Decision Making:** Solve complex problems in scheduling, resource allocation, logistics, and more.
    *   **Automated Reasoning:** Use MiniZinc as a powerful backend for logical inference and constraint satisfaction.
    *   **Interactive Problem Solving:** Build Rust-based tools that allow users to define problems in MiniZinc and get immediate solutions.

## 2. Enhanced Control: Solver Configuration and Statistics

**Current Limitation:** No programmatic way to configure solver parameters (e.g., time limits, search strategies) or retrieve performance statistics.

**Proposed C++ FFI Additions:**

*   **`minizinc_set_solver_option_string(MiniZinc::MznSolver* solver, const char* option_name, const char* value)`**:
    Sets a string-based solver option. (Overloads for `int`, `bool`, `float` would also be beneficial).

*   **`minizinc_get_solver_statistics_int(MiniZinc::MznSolver* solver, const char* stat_name, int* value) -> bool`**:
    Retrieves an integer solver statistic (e.g., number of nodes, failures). (Similar for `float` statistics).

**Proposed Rust FFI Additions:**

*   **`MiniZincEnvironment` methods:**
    ```rust
    impl MiniZincEnvironment {
        pub fn set_solver_option_string(&self, option_name: &str, value: &str) { /* ... */ }
        // ... similar methods for int, bool, float
        pub fn get_solver_statistics_int(&self, stat_name: &str) -> Result<i32, String> { /* ... */ }
        // ... similar methods for float
    }
    ```

**Value Extraction ("Zinc Oxide"):**
    *   **Fine-tuned Performance:** Optimize solver behavior for specific problem instances or hardware.
    *   **Benchmarking and Analysis:** Collect detailed performance metrics for research, development, and comparison.
    *   **Adaptive Solving:** Implement dynamic strategies in Rust that adjust solver parameters based on problem characteristics or intermediate results.

## 3. Improved Diagnostics: Granular Error/Warning Handling

**Current Limitation:** Basic error indication during parsing, but no detailed access to MiniZinc's internal error or warning messages.

**Proposed C++ FFI Additions:**

*   **`minizinc_get_last_error_message(MiniZinc::MznSolver* solver) -> const char*`**:
    Retrieves the last detailed error message generated by the MiniZinc environment.

**Proposed Rust FFI Additions:**

*   **`MiniZincEnvironment` method:**
    ```rust
    impl MiniZincEnvironment {
        pub fn get_last_error_message(&self) -> Option<String> { /* ... */ }
    }
    ```

**Value Extraction ("Zinc Oxide"):**
    *   **Better User Experience:** Provide more informative error messages to end-users of Rust applications.
    *   **Streamlined Debugging:** Pinpoint issues within MiniZinc models or data more effectively from the Rust side.
    *   **Automated Problem Diagnosis:** Build tools that can analyze MiniZinc output for specific warnings or errors.

## Summary of "Zinc Oxide" (Overall Value Proposition):

Implementing these FFI extensions would transform the `minizinc_ffi` crate from a mere parser into a comprehensive and powerful binding for MiniZinc. This would enable Rust developers to:

*   **Build full-fledged constraint programming applications** directly in Rust, leveraging MiniZinc's robust solving capabilities.
*   **Integrate MiniZinc seamlessly** into larger Rust systems, such as data analysis pipelines, AI agents, or web services.
*   **Gain fine-grained control** over the MiniZinc solving process, optimizing for performance and specific problem requirements.
*   **Improve the robustness and user-friendliness** of MiniZinc-powered Rust applications through detailed diagnostics.

This significantly increases the utility and "oxidization" of MiniZinc within the Rust ecosystem, making it a much more valuable component for a wider range of applications.
