void mip_domains(Env& env, bool fVerbose = false, int nmi = 0, double dmd = 3.0);
./include/minizinc/MIPdomains.hh
  static Call* commutativeNormalized(EnvI& env, const Call* orig);
class EnvI;
  friend Expression* copy(EnvI& env, CopyMap& m, Expression* e, bool followIds, bool copyFundecls,
  void canonicaliseStruct(EnvI& env);
  void mkVar(const EnvI& env);
  void mkPar(EnvI& env);
  void setStructDomain(EnvI& env, const Type& struct_type, bool setTypeAny = false,
  bool resolveAlias(EnvI& env);
  bool concatDomain(EnvI& env);
class EnvI;
  typedef Expression* (*builtin_e)(EnvI&, Call*);
  typedef IntVal (*builtin_i)(EnvI&, Call*);
  typedef bool (*builtin_b)(EnvI&, Call*);
  typedef FloatVal (*builtin_f)(EnvI&, Call*);
  typedef IntSetVal* (*builtin_s)(EnvI&, Call*);
  typedef FloatSetVal* (*builtin_fs)(EnvI&, Call*);
  typedef std::string (*builtin_str)(EnvI&, Call*);
  Type rtype(EnvI& env, const std::vector<Expression*>& ta, Expression* call, bool strictEnums);
  Type rtype(EnvI& env, const std::vector<Type>& ta, Expression* call, bool strictEnums);
  Type argtype(EnvI& env, const std::vector<Expression*>& ta, unsigned int n) const;
./include/minizinc/ast.hh
  LocationException(EnvI& env, const Location& loc, const std::string& msg);
  IncludeError(EnvI& env, const Location& loc, const std::string& msg)
  TypeError(EnvI& env, const Location& loc, const std::string& msg)
  EvalError(EnvI& env, const Location& loc, const std::string& msg)
  EvalError(EnvI& env, const Location& loc, const std::string& msg, const ASTString& name)
  AssertionError(EnvI& env, const Location& loc, const std::string& msg)
  ModelInconsistent(EnvI& env, const Location& loc, const std::string& msg = "")
  ResultUndefinedError(EnvI& env, const Location& loc, const std::string& msg);
./include/minizinc/astexception.hh
void register_builtins(Env& env);
./include/minizinc/builtins.hh
  ChainCompressor(EnvI& env, Model& m, std::vector<VarDecl*>& deletedVarDecls)
  EnvI& _env;
  ImpCompressor(EnvI& env, Model& m, std::vector<VarDecl*>& deletedVarDecls,
  LECompressor(EnvI& env, Model& m, std::vector<VarDecl*>& deletedVarDecls)
./include/minizinc/chain_compressor.hh
Expression* copy(EnvI& env, Expression* e, bool followIds = false, bool copyFundecls = false,
Item* copy(EnvI& env, Item* i, bool followIds = false, bool copyFundecls = false,
Model* copy(EnvI& env, Model* m);
Expression* copy(EnvI& env, CopyMap& map, Expression* e, bool followIds = false,
Item* copy(EnvI& env, CopyMap& map, Item* i, bool followIds = false, bool copyFundecls = false,
Model* copy(EnvI& env, CopyMap& cm, Model* m, bool isFlatModel = false);
./include/minizinc/copy.hh
IntVal eval_int_internal(EnvI& env, Expression* e);
inline IntVal eval_int(EnvI& env, Expression* e) {
bool eval_bool(EnvI& env, Expression* e);
FloatVal eval_float(EnvI& env, Expression* e);
ArrayLit* eval_array_lit(EnvI& env, Expression* e);
  std::string errorMessage(EnvI& env, Expression* e) const;
  Expression* dummyLiteral(EnvI& env, Type t) const;
Expression* eval_arrayaccess(EnvI& env, ArrayLit* al, const IdxV& idx, ArrayAccessSucess& success) {
Expression* eval_arrayaccess(EnvI& env, ArrayAccess* e, ArrayAccessSucess& success);
SetLit* eval_set_lit(EnvI& env, Expression* e);
IntSetVal* eval_intset(EnvI& env, Expression* e);
IntSetVal* eval_boolset(EnvI& env, Expression* e);
FloatSetVal* eval_floatset(EnvI& env, Expression* e);
std::string eval_string(EnvI& env, Expression* e);
Expression* eval_par(EnvI& env, Expression* e);
void eval_static_function_body(EnvI& env, FunctionI* decl, Model& toAdd);
void check_par_declaration(EnvI& env, VarDecl* vd);
void check_par_domain(EnvI& env, VarDecl* vd, Expression* rhs, bool isArg = false);
ArrayLit* eval_record_merge(EnvI& env, ArrayLit* lhs, ArrayLit* rhs);
IntBounds compute_int_bounds(EnvI& env, Expression* e);
FloatBounds compute_float_bounds(EnvI& env, Expression* e);
IntSetVal* compute_intset_bounds(EnvI& env, Expression* e);
  static bool evalBoolCV(EnvI& env, Expression* e);
  static KeepAlive flattenCV(EnvI& env, Expression* e);
void eval_comp_array(EnvI& env, Eval& eval, Comprehension* e, int gen, int id, KeepAlive in,
void eval_comp_set(EnvI& env, Eval& eval, Comprehension* e, int gen, int id, KeepAlive in,
void eval_comp_array(EnvI& env, Eval& eval, Comprehension* e, int gen, int id, IntVal i,
void eval_comp_set(EnvI& env, Eval& eval, Comprehension* e, int gen, int id, KeepAlive in,
void eval_comp_array(EnvI& env, Eval& eval, Comprehension* e, int gen, int id, KeepAlive in,
EvaluatedComp<typename Eval::ArrayVal> eval_comp(EnvI& env, Eval& eval, Comprehension* e) {
EvaluatedComp<typename Eval::ArrayVal> eval_comp(EnvI& env, Comprehension* e) {
./include/minizinc/eval_par.hh
void add_path_annotation(EnvI& env, Expression* e);
bool istrue(EnvI& env, Expression* e);
bool isfalse(EnvI& env, Expression* e);
Expression* create_dummy_value(EnvI& env, const Type& t);
TypeInst* eval_typeinst(EnvI& env, const Ctx& ctx, VarDecl* vd);
KeepAlive bind(EnvI& env, Ctx ctx, VarDecl* vd, Expression* e);
KeepAlive conj(EnvI& env, VarDecl* b, const Ctx& ctx, const std::vector<EE>& e);
void flatten_vardecl_annotations(EnvI& env, VarDecl* origVd, VarDeclI* vdi, VarDecl* toAnnotate);
VarDecl* new_vardecl(EnvI& env, const Ctx& ctx, TypeInst* ti, Id* origId, VarDecl* origVd,
KeepAlive flat_cv_exp(EnvI& env, Ctx ctx, Expression* e);
void make_defined_var(EnvI& env, VarDecl* vd, Call* c);
void check_index_sets(EnvI& env, VarDecl* vd, Expression* e, bool isArg = false);
Expression* mk_domain_constraint(EnvI& env, Expression* expr, Expression* dom);
  EnvI& env;
  CallArgItem(EnvI& env0);
./include/minizinc/flat_exp.hh
  FlatteningError(EnvI& env, const Location& loc, const std::string& msg);
  virtual Env* run(Env* env, std::ostream& log) = 0;
void flatten(Env& e, FlatteningOptions opt = FlatteningOptions());
void oldflatzinc(Env& e);
void populate_output(Env& e, bool encapsulateJSON);
FlatModelStatistics statistics(Env& m);
./include/minizinc/flatten.hh
  void add(EnvI& env, ASTString section, Expression* e, bool json);
  bool containsArray(const EnvI& env) const;
  bool isSubtypeOf(const EnvI& env, const TupleType& other, bool strictEnum) const {
  bool matchesBT(const EnvI& env, const TupleType& other) const;
  bool isSubtypeOf(const EnvI& env, const RecordType& other, bool strictEnum) const {
  bool matchesBT(const EnvI& env, const RecordType& other) const;
class EnvI {
  friend KeepAlive add_coercion(EnvI& env, Model* m, Expression* e, const Location& loc_default,
  friend Type type_from_tmap(EnvI& env, TypeInst* ti,
  EnvI(Model* model0, std::ostream& outstream0 = std::cout, std::ostream& errstream0 = std::cerr);
  ~EnvI();
  void copyPathMapsAndState(EnvI& env);
inline VarDecl* Ctx::partialityVar(EnvI& env) const {
void set_computed_domain(EnvI& envi, VarDecl* vd, Expression* domain, bool is_computed);
EE flat_exp(EnvI& env, const Ctx& ctx, Expression* e, VarDecl* r, VarDecl* b);
EE flatten_id(EnvI& env, const Ctx& ctx, Expression* e, VarDecl* r, VarDecl* b,
ArrayLit* field_slice(EnvI& env, StructType* st, ArrayLit* al,
std::vector<Expression*> field_slices(EnvI& env, Expression* arrExpr);
  static Val eval(EnvI& env, Expression* e) { return eval_int(env, e); }
  static void constructLinBuiltin(EnvI& env, BinOpType bot, ASTString& callid, int& coeff_sign,
  static Bounds computeBounds(EnvI& env, Expression* e) { return compute_int_bounds(env, e); }
  static Domain evalDomain(EnvI& env, Expression* e) { return eval_intset(env, e); }
  static Val eval(EnvI& env, Expression* e) { return eval_float(env, e); }
  static void constructLinBuiltin(EnvI& env, BinOpType bot, ASTString& callid, int& coeff_sign,
  static Bounds computeBounds(EnvI& env, Expression* e) { return compute_float_bounds(env, e); }
  static Domain evalDomain(EnvI& env, Expression* e) { return eval_floatset(env, e); }
void cse_result_change_ctx(EnvI& env, Expression* cseRes, BCtx newCtx);
./include/minizinc/flatten_internal.hh
  std::unique_ptr<Env> _pEnv;
    if (_pEnv != nullptr) {
      _pEnv->envi().cancel();
  Env* getEnv() const {
    assert(_pEnv.get());
    return _pEnv.get();
  Env* multiPassFlatten(const std::vector<std::unique_ptr<Pass> >& passes);
./include/minizinc/flattener.hh
  static std::vector<HtmlDocument> printHtml(EnvI& env, Model* m, const std::string& basename,
  static std::vector<HtmlDocument> printRST(EnvI& env, Model* m, const std::string& basename,
./include/minizinc/htmlprinter.hh
  JSONError(EnvI& env, const Location& loc, const std::string& msg)
  EnvI& _env;
  JSONParser(EnvI& env) : _env(env) {}
./include/minizinc/json_parser.hh
class EnvI;
  friend Model* copy(EnvI& env, CopyMap& cm, Model* m, bool isFlatModel);
    FnEntry(EnvI& env, FunctionI* fi0);
    static bool checkPoly(const EnvI& env, const Type& t);
    static bool compare(const EnvI& env, const FnEntry& e1, const FnEntry& e2);
  static void addPolymorphicInstances(EnvI& env, Model::FnEntry& fe, std::vector<FnEntry>& entries);
  bool registerFn(EnvI& env, FunctionI* fi, bool keepSorted = false, bool throwIfDuplicate = true);
  void sortFn(const EnvI& env);
  void sortFn(const EnvI& env, FunctionI* fi);
  void checkFnOverloading(EnvI& env);
  void checkFnValid(EnvI& env, std::vector<TypeError>& errors);
  FunctionI* matchReification(EnvI& env, const ASTString& id, const std::vector<Expression*>& args,
  FunctionI* matchReification(EnvI& env, const ASTString& id, const std::vector<Type>& t,
  FunctionI* matchFn(EnvI& env, const ASTString& id, const std::vector<Expression*>& args,
  FunctionI* matchFn(EnvI& env, const ASTString& id, const std::vector<Type>& t,
  FunctionI* matchFn(EnvI& env, Call* c, bool strictEnums, bool throwIfNotFound = false) const;
  std::vector<FunctionI*> potentialOverloads(EnvI& env, Call* c) const;
  FunctionI* matchRevMap(EnvI& env, const Type& t) const;
  bool fnExists(EnvI& env, const ASTString& id) const;
  std::vector<FunctionI*> possibleMatches(EnvI& env, const ASTString& ident,
  bool sameOverloading(EnvI& env, const std::vector<Expression*>& args, FunctionI* f,
  void mergeStdLib(EnvI& env, Model* m) const;
class EnvI;
/// Environment
class Env {
  EnvI* _e;
  Env(Model* m = nullptr, std::ostream& outstream = std::cout, std::ostream& errstream = std::cerr);
  ~Env();
  EnvI& envi();
  const EnvI& envi() const;
  VarDecl* partialityVar(EnvI& env) const;
  EnvI& _env;
  CallStackItem(EnvI& env0, Expression* e, const Ctx& ctx = Ctx());
  CallStackItem(EnvI& env0, Id* ident, IntVal i);
./include/minizinc/model.hh
  void unify(EnvI& env, Model* m, Id* id0, Id* id1);
  EnvI& env;
  CollectOccurrencesE(EnvI& env0, VarOccurrences& vo0, Item* ci0) : env(env0), vo(vo0), ci(ci0) {}
  EnvI& env;
  CollectOccurrencesI(EnvI& env0, VarOccurrences& vo0) : env(env0), vo(vo0) {}
  EnvI& env;
  CollectDecls(EnvI& env0, VarOccurrences& vo0, std::vector<VarDecl*>& vd0, Item* item0)
void optimize(Env& env, bool chain_compression = true);
void substitute_fixed_vars(Env& env);
./include/minizinc/optimize.hh
  typedef ConstraintStatus (*optimizer)(EnvI& env, Item* i, Call* c, Expression*& rewrite);
  ConstraintStatus process(EnvI& env, Item* i, Call* c, Expression*& rewrite);
./include/minizinc/optimize_constraints.hh
void copy_output(EnvI& e);
void output_vardecls(EnvI& env, Item* ci, Expression* e);
void process_toplevel_output_vars(EnvI& e);
void create_output(EnvI& e, FlatteningOptions::OutputMode outputMode, bool outputObjective,
void check_output_par_fn(EnvI& e, Call* rhs);
void finalise_output(EnvI& e);
void cleanup_output(EnvI& env);
ArrayLit* create_json_output(EnvI& env, bool includeObjective, bool includeOutputItem,
inline void display_enum_range(std::ostringstream& ss, EnvI& env, IntVal min, IntVal max,
./include/minizinc/output.hh
Model* parse(Env& env, const std::vector<std::string>& filenames,
Model* parse_from_string(Env& env, const std::string& text, const std::string& filename,
Model* parse_data(Env& env, Model* m, const std::vector<std::string>& datafiles,
./include/minizinc/parser.hh
  Env* _env;
  CompilePass(Env* e, FlatteningOptions& opts, CompilePassFlags& cflags,
  Env* run(Env* store, std::ostream& log) override;
./include/minizinc/passes/compile_pass.hh
  Env* run(Env* e, std::ostream& log) override;
./include/minizinc/passes/gecode_pass.hh
  PathFilePrinter(std::ostream& o, EnvI& envi);
./include/minizinc/pathfileprinter.hh
  EnvI* _env;
  Printer(std::ostream& os, int width = 80, bool flatZinc = true, EnvI* env = nullptr);
  EnvI& _env;
  FznJSONPrinter(std::ostream& os, EnvI& env) : _os(os), _env(env) {}
std::string show_enum_type(EnvI& env, Expression* e, Type t, bool dzn, bool json);
std::string show_with_type(EnvI& env, Expression* exp, Type t, bool showDzn);
void debugprint(const MiniZinc::Expression* e, MiniZinc::EnvI& env);
void debugprint(const MiniZinc::KeepAlive& e, MiniZinc::EnvI& env);
void debugprint(const MiniZinc::Item* i, MiniZinc::EnvI& env);
void debugprint(const MiniZinc::Model* m, MiniZinc::EnvI& env);
void debugprint(const MiniZinc::Location& l, const MiniZinc::EnvI& env);
void debugprint(const MiniZinc::Type& t, const MiniZinc::EnvI& env);
void debugprint(const std::vector<MiniZinc::Expression*>& x, MiniZinc::EnvI& env);
void debugprint(const std::vector<MiniZinc::VarDecl*>& x, MiniZinc::EnvI& env);
void debugprint(const std::vector<MiniZinc::KeepAlive>& x, MiniZinc::EnvI& env);
void debugprint(const std::vector<MiniZinc::Item*>& x, MiniZinc::EnvI& env);
void debugprint(const std::vector<MiniZinc::Type>& x, MiniZinc::EnvI& env);
./include/minizinc/prettyprinter.hh
  std::unique_ptr<Env> _envGuard;
  Env* _env = nullptr;
  /// passing Env* containing output()
  bool initFromEnv(Env* pE);
  Env* getEnv() const { return _env; }
    assert(getEnv()->output());
    return getEnv()->output();
./include/minizinc/solns2out.hh
  virtual SolverInstanceBase* doCreateSI(Env&, std::ostream&, SolverInstanceBase::Options* opt) = 0;
  SolverInstanceBase* createSI(Env& env, std::ostream& log, SolverInstanceBase::Options* opt);
./include/minizinc/solver.hh
  Env& _env;
  SolverInstanceBase(Env& env, std::ostream& log, Options* options)
  virtual Env* getEnv() const {
  virtual Env& env() const { return *getEnv(); }
  void cleanupForNonincrementalSolving() const { getEnv()->envi().cleanupExceptOutput(); }
  SolverInstanceBase2(Env& env, std::ostream& log, SolverInstanceBase::Options* opt)
  SolverInstanceImpl(Env& env, std::ostream& log, SolverInstanceBase::Options* opt)
./include/minizinc/solver_instance_base.hh
  MIPSolverinstance(Env& env, std::ostream& log, typename MIPWrapper::FactoryOptions& factoryOpt,
  SolverInstanceBase* doCreateSI(Env& env, std::ostream& log,
./include/minizinc/solvers/MIP/MIP_solverinstance.hh
  AtlantisSolverInstance(Env& env, std::ostream& log, SolverInstanceBase::Options* opt);
  SolverInstanceBase* doCreateSI(Env& env, std::ostream& log,
./include/minizinc/solvers/atlantis_solverinstance.hh
  ChuffedSolverInstance(Env& env, std::ostream& log, SolverInstanceBase::Options* opt);
  SolverInstanceBase* doCreateSI(Env& env, std::ostream& log,
./include/minizinc/solvers/chuffed_solverinstance.hh
  FZNSolverInstance(Env& env, std::ostream& log, SolverInstanceBase::Options* opt);
  SolverInstanceBase* doCreateSI(Env& env, std::ostream& log,
./include/minizinc/solvers/fzn_solverinstance.hh
  GeasSolverInstance(Env& env, std::ostream& log, SolverInstanceBase::Options* opt);
  SolverInstanceBase* doCreateSI(Env& env, std::ostream& log,
./include/minizinc/solvers/geas_solverinstance.hh
  GecodeSolverInstance(Env& env, std::ostream& log, SolverInstanceBase::Options* opt);
  Gecode::IntSet arg2intset(EnvI& envi, Expression* arg);
  Gecode::IntSetArgs arg2intsetargs(EnvI& envi, Expression* arg, int offset = 0);
  SolverInstanceBase* doCreateSI(Env& env, std::ostream& log,
./include/minizinc/solvers/gecode_solverinstance.hh
  MZNSolverInstance(Env& env, std::ostream& log, SolverInstanceBase::Options* opt);
  SolverInstanceBase* doCreateSI(Env& env, std::ostream& log,
./include/minizinc/solvers/mzn_solverinstance.hh
  NLSolverInstance(Env& env, std::ostream& log, SolverInstanceBase::Options* opt);
  SolverInstanceBase* doCreateSI(Env& env, std::ostream& log,
./include/minizinc/solvers/nl/nl_solverinstance.hh
class EnvI;
  StackDump(EnvI& env);
  EnvI* _env;
./include/minizinc/stackdump.hh
class EnvI;
   * This is an index into a table in the Env. It is currently limited to
  void mkPar(EnvI& env);
  void mkVar(EnvI& env);
  void mkOpt(EnvI& env);
  void mkPresent(EnvI& env);
  bool decrement(EnvI& env);
  bool isVarifiable(const EnvI& env) const;
  bool contains(const EnvI& env, std::function<bool(const Type)> p) const;
  Type elemType(const EnvI& env) const;
  static Type arrType(EnvI& env, const Type& dimTy, const Type& elemTy);
  std::string toString(const EnvI& env) const;
  static bool btSubtype(const EnvI& env, const Type& t0, const Type& t1, bool strictEnums);
  static Type commonType(EnvI& env, Type t1, Type t2);
  bool isSubtypeOf(const EnvI& env, const Type& t, bool strictEnums) const {
./include/minizinc/type.hh
  void add(EnvI& env, VarDecl* vd);
  void add(EnvI& env, VarDeclI* vd, bool handleEnums, Model* enumItems);
  VarDecl* get(EnvI& env, const ASTString& id, const Location& loc);
  VarDecl* checkId(EnvI& env, Id* ident, const Location& loc);
  void run(EnvI& env, Expression* e);
  virtual void retype(EnvI& env, FunctionI* fi) = 0;
  virtual void reset(EnvI& env, FunctionI* fi) = 0;
void typecheck(Env& env, Model* origModel, std::vector<TypeError>& typeErrors,
void typecheck(Env& env, Model* m, AssignI* ai);
void type_specialise(Env& env, Model* origModel, TyperFn& typer);
void type_demonomorphise_library(Env& e, Model* model);
void output_model_interface(Env& env, Model* m, std::ostream& os,
void output_model_variable_types(Env& env, Model* m, std::ostream& os,
./include/minizinc/typecheck.hh
class Env;
  static void setEnv(Env& env);
  static void removeEnv();
./include/minizinc/utils.hh
  Warning(EnvI& env, const Location& loc, std::string msg)
./include/minizinc/warning.hh
void mip_domains(Env& env, bool fVerbose = false, int nmi = 0, double dmd = 3.0);
./install/include/minizinc/MIPdomains.hh
  static Call* commutativeNormalized(EnvI& env, const Call* orig);
class EnvI;
  friend Expression* copy(EnvI& env, CopyMap& m, Expression* e, bool followIds, bool copyFundecls,
  void canonicaliseStruct(EnvI& env);
  void mkVar(const EnvI& env);
  void mkPar(EnvI& env);
  void setStructDomain(EnvI& env, const Type& struct_type, bool setTypeAny = false,
  bool resolveAlias(EnvI& env);
  bool concatDomain(EnvI& env);
class EnvI;
  typedef Expression* (*builtin_e)(EnvI&, Call*);
  typedef IntVal (*builtin_i)(EnvI&, Call*);
  typedef bool (*builtin_b)(EnvI&, Call*);
  typedef FloatVal (*builtin_f)(EnvI&, Call*);
  typedef IntSetVal* (*builtin_s)(EnvI&, Call*);
  typedef FloatSetVal* (*builtin_fs)(EnvI&, Call*);
  typedef std::string (*builtin_str)(EnvI&, Call*);
  Type rtype(EnvI& env, const std::vector<Expression*>& ta, Expression* call, bool strictEnums);
  Type rtype(EnvI& env, const std::vector<Type>& ta, Expression* call, bool strictEnums);
  Type argtype(EnvI& env, const std::vector<Expression*>& ta, unsigned int n) const;
./install/include/minizinc/ast.hh
  LocationException(EnvI& env, const Location& loc, const std::string& msg);
  IncludeError(EnvI& env, const Location& loc, const std::string& msg)
  TypeError(EnvI& env, const Location& loc, const std::string& msg)
  EvalError(EnvI& env, const Location& loc, const std::string& msg)
  EvalError(EnvI& env, const Location& loc, const std::string& msg, const ASTString& name)
  AssertionError(EnvI& env, const Location& loc, const std::string& msg)
  ModelInconsistent(EnvI& env, const Location& loc, const std::string& msg = "")
  ResultUndefinedError(EnvI& env, const Location& loc, const std::string& msg);
./install/include/minizinc/astexception.hh
void register_builtins(Env& env);
./install/include/minizinc/builtins.hh
  ChainCompressor(EnvI& env, Model& m, std::vector<VarDecl*>& deletedVarDecls)
  EnvI& _env;
  ImpCompressor(EnvI& env, Model& m, std::vector<VarDecl*>& deletedVarDecls,
  LECompressor(EnvI& env, Model& m, std::vector<VarDecl*>& deletedVarDecls)
./install/include/minizinc/chain_compressor.hh
Expression* copy(EnvI& env, Expression* e, bool followIds = false, bool copyFundecls = false,
Item* copy(EnvI& env, Item* i, bool followIds = false, bool copyFundecls = false,
Model* copy(EnvI& env, Model* m);
Expression* copy(EnvI& env, CopyMap& map, Expression* e, bool followIds = false,
Item* copy(EnvI& env, CopyMap& map, Item* i, bool followIds = false, bool copyFundecls = false,
Model* copy(EnvI& env, CopyMap& cm, Model* m, bool isFlatModel = false);
./install/include/minizinc/copy.hh
IntVal eval_int_internal(EnvI& env, Expression* e);
inline IntVal eval_int(EnvI& env, Expression* e) {
bool eval_bool(EnvI& env, Expression* e);
FloatVal eval_float(EnvI& env, Expression* e);
ArrayLit* eval_array_lit(EnvI& env, Expression* e);
  std::string errorMessage(EnvI& env, Expression* e) const;
  Expression* dummyLiteral(EnvI& env, Type t) const;
Expression* eval_arrayaccess(EnvI& env, ArrayLit* al, const IdxV& idx, ArrayAccessSucess& success) {
Expression* eval_arrayaccess(EnvI& env, ArrayAccess* e, ArrayAccessSucess& success);
SetLit* eval_set_lit(EnvI& env, Expression* e);
IntSetVal* eval_intset(EnvI& env, Expression* e);
IntSetVal* eval_boolset(EnvI& env, Expression* e);
FloatSetVal* eval_floatset(EnvI& env, Expression* e);
std::string eval_string(EnvI& env, Expression* e);
Expression* eval_par(EnvI& env, Expression* e);
void eval_static_function_body(EnvI& env, FunctionI* decl, Model& toAdd);
void check_par_declaration(EnvI& env, VarDecl* vd);
void check_par_domain(EnvI& env, VarDecl* vd, Expression* rhs, bool isArg = false);
ArrayLit* eval_record_merge(EnvI& env, ArrayLit* lhs, ArrayLit* rhs);
IntBounds compute_int_bounds(EnvI& env, Expression* e);
FloatBounds compute_float_bounds(EnvI& env, Expression* e);
IntSetVal* compute_intset_bounds(EnvI& env, Expression* e);
  static bool evalBoolCV(EnvI& env, Expression* e);
  static KeepAlive flattenCV(EnvI& env, Expression* e);
void eval_comp_array(EnvI& env, Eval& eval, Comprehension* e, int gen, int id, KeepAlive in,
void eval_comp_set(EnvI& env, Eval& eval, Comprehension* e, int gen, int id, KeepAlive in,
void eval_comp_array(EnvI& env, Eval& eval, Comprehension* e, int gen, int id, IntVal i,
void eval_comp_set(EnvI& env, Eval& eval, Comprehension* e, int gen, int id, KeepAlive in,
void eval_comp_array(EnvI& env, Eval& eval, Comprehension* e, int gen, int id, KeepAlive in,
EvaluatedComp<typename Eval::ArrayVal> eval_comp(EnvI& env, Eval& eval, Comprehension* e) {
EvaluatedComp<typename Eval::ArrayVal> eval_comp(EnvI& env, Comprehension* e) {
./install/include/minizinc/eval_par.hh
void add_path_annotation(EnvI& env, Expression* e);
bool istrue(EnvI& env, Expression* e);
bool isfalse(EnvI& env, Expression* e);
Expression* create_dummy_value(EnvI& env, const Type& t);
TypeInst* eval_typeinst(EnvI& env, const Ctx& ctx, VarDecl* vd);
KeepAlive bind(EnvI& env, Ctx ctx, VarDecl* vd, Expression* e);
KeepAlive conj(EnvI& env, VarDecl* b, const Ctx& ctx, const std::vector<EE>& e);
void flatten_vardecl_annotations(EnvI& env, VarDecl* origVd, VarDeclI* vdi, VarDecl* toAnnotate);
VarDecl* new_vardecl(EnvI& env, const Ctx& ctx, TypeInst* ti, Id* origId, VarDecl* origVd,
KeepAlive flat_cv_exp(EnvI& env, Ctx ctx, Expression* e);
void make_defined_var(EnvI& env, VarDecl* vd, Call* c);
void check_index_sets(EnvI& env, VarDecl* vd, Expression* e, bool isArg = false);
Expression* mk_domain_constraint(EnvI& env, Expression* expr, Expression* dom);
  EnvI& env;
  CallArgItem(EnvI& env0);
./install/include/minizinc/flat_exp.hh
  FlatteningError(EnvI& env, const Location& loc, const std::string& msg);
  virtual Env* run(Env* env, std::ostream& log) = 0;
void flatten(Env& e, FlatteningOptions opt = FlatteningOptions());
void oldflatzinc(Env& e);
void populate_output(Env& e, bool encapsulateJSON);
FlatModelStatistics statistics(Env& m);
./install/include/minizinc/flatten.hh
  void add(EnvI& env, ASTString section, Expression* e, bool json);
  bool containsArray(const EnvI& env) const;
  bool isSubtypeOf(const EnvI& env, const TupleType& other, bool strictEnum) const {
  bool matchesBT(const EnvI& env, const TupleType& other) const;
  bool isSubtypeOf(const EnvI& env, const RecordType& other, bool strictEnum) const {
  bool matchesBT(const EnvI& env, const RecordType& other) const;
class EnvI {
  friend KeepAlive add_coercion(EnvI& env, Model* m, Expression* e, const Location& loc_default,
  friend Type type_from_tmap(EnvI& env, TypeInst* ti,
  EnvI(Model* model0, std::ostream& outstream0 = std::cout, std::ostream& errstream0 = std::cerr);
  ~EnvI();
  void copyPathMapsAndState(EnvI& env);
inline VarDecl* Ctx::partialityVar(EnvI& env) const {
void set_computed_domain(EnvI& envi, VarDecl* vd, Expression* domain, bool is_computed);
EE flat_exp(EnvI& env, const Ctx& ctx, Expression* e, VarDecl* r, VarDecl* b);
EE flatten_id(EnvI& env, const Ctx& ctx, Expression* e, VarDecl* r, VarDecl* b,
ArrayLit* field_slice(EnvI& env, StructType* st, ArrayLit* al,
std::vector<Expression*> field_slices(EnvI& env, Expression* arrExpr);
  static Val eval(EnvI& env, Expression* e) { return eval_int(env, e); }
  static void constructLinBuiltin(EnvI& env, BinOpType bot, ASTString& callid, int& coeff_sign,
  static Bounds computeBounds(EnvI& env, Expression* e) { return compute_int_bounds(env, e); }
  static Domain evalDomain(EnvI& env, Expression* e) { return eval_intset(env, e); }
  static Val eval(EnvI& env, Expression* e) { return eval_float(env, e); }
  static void constructLinBuiltin(EnvI& env, BinOpType bot, ASTString& callid, int& coeff_sign,
  static Bounds computeBounds(EnvI& env, Expression* e) { return compute_float_bounds(env, e); }
  static Domain evalDomain(EnvI& env, Expression* e) { return eval_floatset(env, e); }
void cse_result_change_ctx(EnvI& env, Expression* cseRes, BCtx newCtx);
./install/include/minizinc/flatten_internal.hh
  std::unique_ptr<Env> _pEnv;
    if (_pEnv != nullptr) {
      _pEnv->envi().cancel();
  Env* getEnv() const {
    assert(_pEnv.get());
    return _pEnv.get();
  Env* multiPassFlatten(const std::vector<std::unique_ptr<Pass> >& passes);
./install/include/minizinc/flattener.hh
  static std::vector<HtmlDocument> printHtml(EnvI& env, Model* m, const std::string& basename,
  static std::vector<HtmlDocument> printRST(EnvI& env, Model* m, const std::string& basename,
./install/include/minizinc/htmlprinter.hh
  JSONError(EnvI& env, const Location& loc, const std::string& msg)
  EnvI& _env;
  JSONParser(EnvI& env) : _env(env) {}
./install/include/minizinc/json_parser.hh
class EnvI;
  friend Model* copy(EnvI& env, CopyMap& cm, Model* m, bool isFlatModel);
    FnEntry(EnvI& env, FunctionI* fi0);
    static bool checkPoly(const EnvI& env, const Type& t);
    static bool compare(const EnvI& env, const FnEntry& e1, const FnEntry& e2);
  static void addPolymorphicInstances(EnvI& env, Model::FnEntry& fe, std::vector<FnEntry>& entries);
  bool registerFn(EnvI& env, FunctionI* fi, bool keepSorted = false, bool throwIfDuplicate = true);
  void sortFn(const EnvI& env);
  void sortFn(const EnvI& env, FunctionI* fi);
  void checkFnOverloading(EnvI& env);
  void checkFnValid(EnvI& env, std::vector<TypeError>& errors);
  FunctionI* matchReification(EnvI& env, const ASTString& id, const std::vector<Expression*>& args,
  FunctionI* matchReification(EnvI& env, const ASTString& id, const std::vector<Type>& t,
  FunctionI* matchFn(EnvI& env, const ASTString& id, const std::vector<Expression*>& args,
  FunctionI* matchFn(EnvI& env, const ASTString& id, const std::vector<Type>& t,
  FunctionI* matchFn(EnvI& env, Call* c, bool strictEnums, bool throwIfNotFound = false) const;
  std::vector<FunctionI*> potentialOverloads(EnvI& env, Call* c) const;
  FunctionI* matchRevMap(EnvI& env, const Type& t) const;
  bool fnExists(EnvI& env, const ASTString& id) const;
  std::vector<FunctionI*> possibleMatches(EnvI& env, const ASTString& ident,
  bool sameOverloading(EnvI& env, const std::vector<Expression*>& args, FunctionI* f,
  void mergeStdLib(EnvI& env, Model* m) const;
class EnvI;
/// Environment
class Env {
  EnvI* _e;
  Env(Model* m = nullptr, std::ostream& outstream = std::cout, std::ostream& errstream = std::cerr);
  ~Env();
  EnvI& envi();
  const EnvI& envi() const;
  VarDecl* partialityVar(EnvI& env) const;
  EnvI& _env;
  CallStackItem(EnvI& env0, Expression* e, const Ctx& ctx = Ctx());
  CallStackItem(EnvI& env0, Id* ident, IntVal i);
./install/include/minizinc/model.hh
  void unify(EnvI& env, Model* m, Id* id0, Id* id1);
  EnvI& env;
  CollectOccurrencesE(EnvI& env0, VarOccurrences& vo0, Item* ci0) : env(env0), vo(vo0), ci(ci0) {}
  EnvI& env;
  CollectOccurrencesI(EnvI& env0, VarOccurrences& vo0) : env(env0), vo(vo0) {}
  EnvI& env;
  CollectDecls(EnvI& env0, VarOccurrences& vo0, std::vector<VarDecl*>& vd0, Item* item0)
void optimize(Env& env, bool chain_compression = true);
void substitute_fixed_vars(Env& env);
./install/include/minizinc/optimize.hh
  typedef ConstraintStatus (*optimizer)(EnvI& env, Item* i, Call* c, Expression*& rewrite);
  ConstraintStatus process(EnvI& env, Item* i, Call* c, Expression*& rewrite);
./install/include/minizinc/optimize_constraints.hh
void copy_output(EnvI& e);
void output_vardecls(EnvI& env, Item* ci, Expression* e);
void process_toplevel_output_vars(EnvI& e);
void create_output(EnvI& e, FlatteningOptions::OutputMode outputMode, bool outputObjective,
void check_output_par_fn(EnvI& e, Call* rhs);
void finalise_output(EnvI& e);
void cleanup_output(EnvI& env);
ArrayLit* create_json_output(EnvI& env, bool includeObjective, bool includeOutputItem,
inline void display_enum_range(std::ostringstream& ss, EnvI& env, IntVal min, IntVal max,
./install/include/minizinc/output.hh
Model* parse(Env& env, const std::vector<std::string>& filenames,
Model* parse_from_string(Env& env, const std::string& text, const std::string& filename,
Model* parse_data(Env& env, Model* m, const std::vector<std::string>& datafiles,
./install/include/minizinc/parser.hh
  Env* _env;
  CompilePass(Env* e, FlatteningOptions& opts, CompilePassFlags& cflags,
  Env* run(Env* store, std::ostream& log) override;
./install/include/minizinc/passes/compile_pass.hh
  Env* run(Env* e, std::ostream& log) override;
./install/include/minizinc/passes/gecode_pass.hh
  PathFilePrinter(std::ostream& o, EnvI& envi);
./install/include/minizinc/pathfileprinter.hh
  EnvI* _env;
  Printer(std::ostream& os, int width = 80, bool flatZinc = true, EnvI* env = nullptr);
  EnvI& _env;
  FznJSONPrinter(std::ostream& os, EnvI& env) : _os(os), _env(env) {}
std::string show_enum_type(EnvI& env, Expression* e, Type t, bool dzn, bool json);
std::string show_with_type(EnvI& env, Expression* exp, Type t, bool showDzn);
void debugprint(const MiniZinc::Expression* e, MiniZinc::EnvI& env);
void debugprint(const MiniZinc::KeepAlive& e, MiniZinc::EnvI& env);
void debugprint(const MiniZinc::Item* i, MiniZinc::EnvI& env);
void debugprint(const MiniZinc::Model* m, MiniZinc::EnvI& env);
void debugprint(const MiniZinc::Location& l, const MiniZinc::EnvI& env);
void debugprint(const MiniZinc::Type& t, const MiniZinc::EnvI& env);
void debugprint(const std::vector<MiniZinc::Expression*>& x, MiniZinc::EnvI& env);
void debugprint(const std::vector<MiniZinc::VarDecl*>& x, MiniZinc::EnvI& env);
void debugprint(const std::vector<MiniZinc::KeepAlive>& x, MiniZinc::EnvI& env);
void debugprint(const std::vector<MiniZinc::Item*>& x, MiniZinc::EnvI& env);
void debugprint(const std::vector<MiniZinc::Type>& x, MiniZinc::EnvI& env);
./install/include/minizinc/prettyprinter.hh
  std::unique_ptr<Env> _envGuard;
  Env* _env = nullptr;
  /// passing Env* containing output()
  bool initFromEnv(Env* pE);
  Env* getEnv() const { return _env; }
    assert(getEnv()->output());
    return getEnv()->output();
./install/include/minizinc/solns2out.hh
  virtual SolverInstanceBase* doCreateSI(Env&, std::ostream&, SolverInstanceBase::Options* opt) = 0;
  SolverInstanceBase* createSI(Env& env, std::ostream& log, SolverInstanceBase::Options* opt);
./install/include/minizinc/solver.hh
  Env& _env;
  SolverInstanceBase(Env& env, std::ostream& log, Options* options)
  virtual Env* getEnv() const {
  virtual Env& env() const { return *getEnv(); }
  void cleanupForNonincrementalSolving() const { getEnv()->envi().cleanupExceptOutput(); }
  SolverInstanceBase2(Env& env, std::ostream& log, SolverInstanceBase::Options* opt)
  SolverInstanceImpl(Env& env, std::ostream& log, SolverInstanceBase::Options* opt)
./install/include/minizinc/solver_instance_base.hh
  MIPSolverinstance(Env& env, std::ostream& log, typename MIPWrapper::FactoryOptions& factoryOpt,
  SolverInstanceBase* doCreateSI(Env& env, std::ostream& log,
./install/include/minizinc/solvers/MIP/MIP_solverinstance.hh
  AtlantisSolverInstance(Env& env, std::ostream& log, SolverInstanceBase::Options* opt);
  SolverInstanceBase* doCreateSI(Env& env, std::ostream& log,
./install/include/minizinc/solvers/atlantis_solverinstance.hh
  ChuffedSolverInstance(Env& env, std::ostream& log, SolverInstanceBase::Options* opt);
  SolverInstanceBase* doCreateSI(Env& env, std::ostream& log,
./install/include/minizinc/solvers/chuffed_solverinstance.hh
  FZNSolverInstance(Env& env, std::ostream& log, SolverInstanceBase::Options* opt);
  SolverInstanceBase* doCreateSI(Env& env, std::ostream& log,
./install/include/minizinc/solvers/fzn_solverinstance.hh
  GeasSolverInstance(Env& env, std::ostream& log, SolverInstanceBase::Options* opt);
  SolverInstanceBase* doCreateSI(Env& env, std::ostream& log,
./install/include/minizinc/solvers/geas_solverinstance.hh
  GecodeSolverInstance(Env& env, std::ostream& log, SolverInstanceBase::Options* opt);
  Gecode::IntSet arg2intset(EnvI& envi, Expression* arg);
  Gecode::IntSetArgs arg2intsetargs(EnvI& envi, Expression* arg, int offset = 0);
  SolverInstanceBase* doCreateSI(Env& env, std::ostream& log,
./install/include/minizinc/solvers/gecode_solverinstance.hh
  MZNSolverInstance(Env& env, std::ostream& log, SolverInstanceBase::Options* opt);
  SolverInstanceBase* doCreateSI(Env& env, std::ostream& log,
./install/include/minizinc/solvers/mzn_solverinstance.hh
  NLSolverInstance(Env& env, std::ostream& log, SolverInstanceBase::Options* opt);
  SolverInstanceBase* doCreateSI(Env& env, std::ostream& log,
./install/include/minizinc/solvers/nl/nl_solverinstance.hh
class EnvI;
  StackDump(EnvI& env);
  EnvI* _env;
./install/include/minizinc/stackdump.hh
class EnvI;
   * This is an index into a table in the Env. It is currently limited to
  void mkPar(EnvI& env);
  void mkVar(EnvI& env);
  void mkOpt(EnvI& env);
  void mkPresent(EnvI& env);
  bool decrement(EnvI& env);
  bool isVarifiable(const EnvI& env) const;
  bool contains(const EnvI& env, std::function<bool(const Type)> p) const;
  Type elemType(const EnvI& env) const;
  static Type arrType(EnvI& env, const Type& dimTy, const Type& elemTy);
  std::string toString(const EnvI& env) const;
  static bool btSubtype(const EnvI& env, const Type& t0, const Type& t1, bool strictEnums);
  static Type commonType(EnvI& env, Type t1, Type t2);
  bool isSubtypeOf(const EnvI& env, const Type& t, bool strictEnums) const {
./install/include/minizinc/type.hh
  void add(EnvI& env, VarDecl* vd);
  void add(EnvI& env, VarDeclI* vd, bool handleEnums, Model* enumItems);
  VarDecl* get(EnvI& env, const ASTString& id, const Location& loc);
  VarDecl* checkId(EnvI& env, Id* ident, const Location& loc);
  void run(EnvI& env, Expression* e);
  virtual void retype(EnvI& env, FunctionI* fi) = 0;
  virtual void reset(EnvI& env, FunctionI* fi) = 0;
void typecheck(Env& env, Model* origModel, std::vector<TypeError>& typeErrors,
void typecheck(Env& env, Model* m, AssignI* ai);
void type_specialise(Env& env, Model* origModel, TyperFn& typer);
void type_demonomorphise_library(Env& e, Model* model);
void output_model_interface(Env& env, Model* m, std::ostream& os,
void output_model_variable_types(Env& env, Model* m, std::ostream& os,
./install/include/minizinc/typecheck.hh
class Env;
  static void setEnv(Env& env);
  static void removeEnv();
./install/include/minizinc/utils.hh
  Warning(EnvI& env, const Location& loc, std::string msg)
./install/include/minizinc/warning.hh
