use proc_macro::TokenStream;
use quote::{quote, ToTokens};
use syn::{parse_macro_input, ItemFn, Lit, Meta, Ident};

#[proc_macro_attribute]
pub fn minizinc_solve(attr: TokenStream, item: TokenStream) -> TokenStream {
    let input_fn = parse_macro_input!(item as ItemFn);

    let mut model_path = None;
    let mut data_path = None;
    let mut output_type = None;

    // Parse the attribute TokenStream into a Meta
    let attr_meta = parse_macro_input!(attr as Meta);

    if let Meta::List(meta_list) = attr_meta {
        // Iterate over the nested attributes
        for nested_meta in meta_list.nested.into_iter() {
            if let syn::NestedMeta::Meta(meta) = nested_meta {
                if let Meta::NameValue(nv) = meta {
                    if nv.path.is_ident("model") {
                        // Parse the value TokenStream into a Lit
                        let lit_str: Lit = parse_macro_input!(nv.value.to_token_stream() as Lit);
                        if let Lit::Str(lit) = lit_str {
                            model_path = Some(lit.value());
                        }
                    } else if nv.path.is_ident("data") {
                        let lit_str: Lit = parse_macro_input!(nv.value.to_token_stream() as Lit);
                        if let Lit::Str(lit) = lit_str {
                            data_path = Some(lit.value());
                        }
                    } else if nv.path.is_ident("output_type") {
                        let lit_str: Lit = parse_macro_input!(nv.value.to_token_stream() as Lit);
                        if let Lit::Str(lit) = lit_str {
                            output_type = Some(lit.value());
                        }
                    }
                }
            }
        }
    } else {
        panic!("minizinc_solve: Expected a list of attributes (e.g., #[minizinc_solve(model = \"...\")])");
    }


    let model_path = model_path.expect("minizinc_solve: 'model' attribute is required");
    let data_path = data_path.expect("minizinc_solve: 'data' attribute is required");
    let output_type_ident = Ident::new(&output_type.expect("minizinc_solve: 'output_type' attribute is required"), proc_macro2::Span::call_site());

    let fn_name = &input_fn.sig.ident;
    let fn_vis = &input_fn.vis;
    let fn_args = &input_fn.sig.inputs;
    let fn_output = &input_fn.sig.output;
    let fn_block = &input_fn.block;

    let expanded = quote! {
        #fn_vis fn #fn_name(#fn_args) #fn_output {
            // Original function body (if any)
            #fn_block

            // MiniZinc solving logic generated by the macro
            let mut env = minizinc_ffi::MiniZincEnvironment::new();
            let model = env.load_model(#model_path).expect("Failed to load MiniZinc model");
            let data = env.load_data(#data_path).expect("Failed to load MiniZinc data");

            let solution = env.solve(&model, &data).expect("Failed to solve MiniZinc model");

            // Placeholder for parsing the solution
            // In a real scenario, you would parse 'solution' into #output_type_ident
            println!("MiniZinc solution: {}", solution);

            // For now, let's assume output_type_ident is a struct that can be default constructed
            // or we return a dummy value. This needs proper parsing logic.
            #output_type_ident::default() // This will require output_type_ident to implement Default
        }
    };

    expanded.into()
}
