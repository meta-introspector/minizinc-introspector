//! # MiniZinc Procedural Macro
//!
//! This crate provides a procedural macro for solving MiniZinc models.
//!
//! The `minizinc_solve` macro can be used to generate a function that
//! solves a MiniZinc model and returns the result.

use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, ItemFn, Lit, Ident, parse::{Parse, ParseStream}, Token};

/// Arguments for the `minizinc_solve` macro.
struct MiniZincSolveArgs {
    model_path: String,
    data_path: String,
    output_type: String,
}

impl Parse for MiniZincSolveArgs {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        let mut model_path = None;
        let mut data_path = None;
        let mut output_type = None;

        // Parse arguments separated by commas
        while !input.is_empty() {
            let ident: Ident = input.parse()?;
            let _eq_token: Token![=] = input.parse()?;
            let lit: Lit = input.parse()?;

            if ident == "model" {
                if let Lit::Str(s) = lit {
                    model_path = Some(s.value());
                } else {
                    return Err(input.error("Expected string literal for 'model'"));
                }
            } else if ident == "data" {
                if let Lit::Str(s) = lit {
                    data_path = Some(s.value());
                } else {
                    return Err(input.error("Expected string literal for 'data'"));
                }
            } else if ident == "output_type" {
                if let Lit::Str(s) = lit {
                    output_type = Some(s.value());
                } else {
                    return Err(input.error("Expected string literal for 'output_type'"));
                }
            } else {
                return Err(input.error(format!("Unknown attribute: {ident}")));
            }

            if !input.is_empty() {
                let _comma: Token![,] = input.parse()?;
            }
        }

        Ok(MiniZincSolveArgs {
            model_path: model_path.ok_or_else(|| input.error("Missing 'model' attribute"))?,
            data_path: data_path.ok_or_else(|| input.error("Missing 'data' attribute"))?,
            output_type: output_type.ok_or_else(|| input.error("Missing 'output_type' attribute"))?,
        })
    }
}


/// A procedural macro to solve a MiniZinc model.
///
/// This macro generates a function that solves a MiniZinc model using the
/// `minizinc_ffi` crate. The generated function will have the same signature
/// as the function it is attached to, but the body will be replaced with
/// the MiniZinc solving logic.
///
/// # Arguments
///
/// * `model` - The path to the MiniZinc model file.
/// * `data` - The path to the MiniZinc data file.
/// * `output_type` - The type of the value to be returned by the generated
///   function. This type must implement the `Default` trait.
#[proc_macro_attribute]
pub fn minizinc_solve(attr: TokenStream, item: TokenStream) -> TokenStream {
    let args = parse_macro_input!(attr as MiniZincSolveArgs);
    let input_fn = parse_macro_input!(item as ItemFn);

    let model_path = args.model_path;
    let data_path = args.data_path;
    let output_type_ident = Ident::new(&args.output_type, proc_macro2::Span::call_site());

    let fn_name = &input_fn.sig.ident;
    let fn_vis = &input_fn.vis;
    let fn_args = &input_fn.sig.inputs;
    let fn_output = &input_fn.sig.output;
    // Removed fn_block from here, as we will replace the function body

    let expanded = quote! {
        #fn_vis fn #fn_name(#fn_args) #fn_output {
            use std::fs; // Import std::fs in the generated code

            // MiniZinc solving logic generated by the macro
            let mut env = minizinc_ffi::environment::MiniZincEnvironment::new().expect("Failed to create MiniZinc environment");

            let model_code = fs::read_to_string(#model_path).expect(&format!("Failed to read model file: {}", #model_path));
            let model = env.parse_model(&model_code, #model_path).expect("Failed to parse MiniZinc model");

            let data_code = fs::read_to_string(#data_path).expect(&format!("Failed to read data file: {}", #data_path));
            env.parse_data(&model, &data_code, #data_path).expect("Failed to parse MiniZinc data");

            let solver_instance = env.get_solver_instance();

            // Loop through solutions
            let mut solution_found = false;
            // Loop through solutions
            let mut solution_found = false;
            unsafe {
                while env.solver_instance_next(solver_instance) != 0 {
                    env.solver_instance_print_solution(solver_instance);
                    solution_found = true;
                }
            }

            if !solution_found {
                println!("No MiniZinc solution found.");
            }

            // Return the default instance of the specified output type
            #output_type_ident::default() // This will require output_type_ident to implement Default
        }
    };

    expanded.into()
}
