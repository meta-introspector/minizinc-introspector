use std::env;
use std::path::PathBuf;
use std::process::{Command, Stdio};

pub fn determine_project_root() -> Result<PathBuf, String> {
    let current_exe_path = env::current_exe()
        .map_err(|e| format!("Failed to get current executable path: {e}"))?;
    let project_root = current_exe_path.parent()
        .and_then(|p| p.parent()) // target/debug/
        .and_then(|p| p.parent()) // libminizinc/
        .ok_or("Could not determine project root")?;
    Ok(project_root.to_path_buf())
}

pub async fn run_command(cmd: &str, args: &[&str], cwd: Option<&PathBuf>) -> Result<(), String> {
    let mut command = Command::new(cmd);
    command.args(args);
    command.stdout(Stdio::inherit());
    command.stderr(Stdio::inherit());

    if let Some(dir) = cwd {
        command.current_dir(dir);
    }

    eprintln!("Executing: {} {:?}", cmd, args);

    let status = command.status()
        .map_err(|e| format!("Failed to execute command {}: {}", cmd, e))?;

    if status.success() {
        Ok(())
    } else {
        Err(format!("Command {} exited with non-zero status: {:?}", cmd, status.code()))
    }
}
