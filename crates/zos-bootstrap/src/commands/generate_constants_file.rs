use crate::utils::error::Result;
use crate::code_analysis::string_extractor;
use crate::code_analysis::minizinc_param_generator;
use crate::utils::paths;
use crate::utils::subprocess;
use std::path::PathBuf;
use std::str;
use clap::Args;

#[derive(Args, Clone)]
pub struct GenerateConstantsFileArgs {
    #[arg(long)]
    pub output_file: String,
}

pub fn handle_generate_constants_file_command(args: GenerateConstantsFileArgs) -> Result<()> {
    println!("Generating constants.rs file...");
    println!("Output file: {}", args.output_file);

    let project_root = paths::resolve_project_root()?;
    let mut all_extracted_strings = Vec::new();

    // Extract strings from the Rust codebase
    let rust_files = glob::glob(&format!("{}/crates/**/*.rs", project_root.display()))?.filter_map(std::result::Result::ok);

    for entry in rust_files {
        let file_path = entry.as_path();
        let crate_name = file_path
            .strip_prefix(&project_root)?
            .components()
            .nth(1)
            .and_then(|c| c.as_os_str().to_str())
            .unwrap_or("unknown_crate")
            .to_string();

        match string_extractor::extract_strings_from_file(file_path, crate_name) {
            Ok(extracted) => {
                all_extracted_strings.extend(extracted);
            }
            Err(e) => {
                eprintln!("Error extracting strings from {}: {}", file_path.display(), e);
            }
        }
    }
    println!("Extracted {} strings from Rust codebase.", all_extracted_strings.len());

    // Generate MiniZinc data file
    let output_dir = PathBuf::from(args.output_file.clone()).parent().unwrap().to_path_buf();
    std::fs::create_dir_all(&output_dir)?;
    let data_file = output_dir.join("all_extracted_strings.dzn");
    minizinc_param_generator::generate_minizinc_data_file(all_extracted_strings, &data_file)?;

    // Execute MiniZinc to select needed constants
    let libminizinc_build_dir = paths::get_build_dir()?;
    let minizinc_exe = libminizinc_build_dir.join("minizinc");
    let model_file = project_root.join("minizinc_models").join("select_needed_constants.mzn");

    let args_mzn = vec![
        model_file.to_string_lossy().to_string(),
        data_file.to_string_lossy().to_string(),
    ];

    let args_str: Vec<&str> = args_mzn.iter().map(|s| s.as_ref()).collect();

    println!("Running MiniZinc to select needed constants...");
    let output = subprocess::run_command(&minizinc_exe.to_string_lossy(), &args_str)?;

    println!("MiniZinc Output:\n{}", String::from_utf8_lossy(&output.stdout));
    println!("MiniZinc Errors:\n{}", String::from_utf8_lossy(&output.stderr));

    if !output.status.success() {
        return Err(crate::utils::error::ZosError::CommandFailed {
            command: format!("minizinc {}", args_str.join(" ")),
            exit_code: output.status.code(),
            stdout: String::from_utf8_lossy(&output.stdout).to_string(),
            stderr: String::from_utf8_lossy(&output.stderr).to_string(),
        });
    }

    // Parse MiniZinc output to get the selected constants
    let output_str = str::from_utf8(&output.stdout)?;
    let selected_constants_prefix = "selected_constants = [";
    let mut selected_constants: Vec<String> = Vec::new();

    if let Some(start_index) = output_str.find(selected_constants_prefix) {
        let remaining = &output_str[start_index + selected_constants_prefix.len()..];
        if let Some(end_index) = remaining.find("];") {
            let constants_str = &remaining[..end_index];
            for constant_value in constants_str.split(",") {
                let trimmed = constant_value.trim().trim_matches('"').to_string();
                if !trimmed.is_empty() {
                    selected_constants.push(trimmed);
                }
            }
        } else {
            println!("Could not parse selected constants from MiniZinc output: closing bracket not found.");
        }
    } else {
        println!("Could not find selected constants in MiniZinc output: prefix not found.");
    }

    // Generate constants.rs file
    let mut constants_content = String::new();
    constants_content.push_str("// This file is auto-generated by zos-bootstrap\n");
    constants_content.push_str("// Do not edit this file manually\n\n");

    for s in selected_constants {
        let constant_name = to_upper_snake_case(&s);
        constants_content.push_str(&format!("pub const {}: &str = \"{}\";\n", constant_name, s.replace("\"", "\\\"")));
    }

    // std::fs::write(&PathBuf::from(args.output_file), constants_content)?;
    println!("\n--- Generated Constants (Copy and Paste into constants.rs) ---");
    println!("{}", constants_content);
    println!("-----------------------------------------------------------");

    println!("Constants file generation completed. Please manually update constants.rs.");
    Ok(())
}

fn to_upper_snake_case(s: &str) -> String {
    let mut result = String::new();
    let mut last_char_was_uppercase = false;
    let mut last_char_was_digit = false;

    for c in s.chars() {
        if c.is_ascii_alphanumeric() {
            if c.is_ascii_uppercase() {
                if !result.is_empty() && !last_char_was_uppercase && !last_char_was_digit {
                    result.push('_');
                }
                result.push(c);
                last_char_was_uppercase = true;
                last_char_was_digit = false;
            } else if c.is_ascii_lowercase() {
                if !result.is_empty() && last_char_was_uppercase {
                    result.push('_');
                }
                result.push(c.to_ascii_uppercase());
                last_char_was_uppercase = false;
                last_char_was_digit = false;
            } else if c.is_ascii_digit() {
                if !result.is_empty() && !last_char_was_digit {
                    result.push('_');
                }
                result.push(c);
                last_char_was_uppercase = false;
                last_char_was_digit = true;
            }
        } else {
            if !result.is_empty() && result.chars().last() != Some('_') {
                result.push('_');
            }
            last_char_was_uppercase = false;
            last_char_was_digit = false;
        }
    }
    result.trim_matches('_').to_string()
}

