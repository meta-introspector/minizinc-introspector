use anyhow::Result;
use linkme::distributed_slice;
use poem_traits::{PoemFrontMatterTrait, Meme}; // Import Meme from poem_traits

// Define the distributed slice where functions will register themselves
#[distributed_slice]
pub static FUNCTIONS2: [&'static (String, fn() -> Box<dyn Fn(&str, Vec<String>, &mut dyn PoemFrontMatterTrait) -> Result<(), anyhow::Error> + Send + Sync + 'static>)];

// This is a placeholder function. The actual function will be generated by the macro.
// pub fn create_function_registry() -> &'static HashMap<String, Box<dyn Fn(&str, Vec<String>, &mut dyn PoemFrontMatterTrait) -> Result<(), anyhow::Error> + Send + Sync + 'static>> {
//     static REGISTRY: once_cell::sync::Lazy<HashMap<String, Box<dyn Fn(&str, Vec<String>, &mut dyn PoemFrontMatterTrait) -> Result<(), anyhow::Error> + Send + Sync + 'static>>> = once_cell::sync::Lazy::new(|| {
//         let mut registry = HashMap::new();
//         // The FUNCTIONS static is generated by the poem_header macro.
//         // We iterate over it here to populate the registry.
//         // This code will be replaced by the macro's generated code.
//         // For now, we'll just return an empty HashMap to allow compilation.
//         // for (name, callback_fn_getter) in FUNCTIONS {
//         //     registry.insert(name.clone(), callback_fn_getter());
//         // }
//         registry
//     });
//     &REGISTRY
// }

// Extracted callback functions with #[poem_function] attribute
#[poem_macros::poem_function]
#[allow(non_snake_case)]
pub fn _handle_old_meme_regex(_line: &str, captures: Vec<String>, fixed_fm: &mut dyn PoemFrontMatterTrait) -> Result<(), anyhow::Error> {
    let description = captures[1].trim().to_string();
    let template = captures[2].trim().to_string();
    fixed_fm.get_memes_mut().push(Meme {
        description,
        template,
        traits: None,
        nft_id: None,
        lore: None,
        numerology: None,
    });
    Ok(())
}

#[poem_macros::poem_function]
#[allow(non_snake_case)]
pub fn _handle_new_meme_desc_regex(_line: &str, captures: Vec<String>, fixed_fm: &mut dyn PoemFrontMatterTrait) -> Result<(), anyhow::Error> {
    *fixed_fm.get_pending_meme_description_mut() = Some(captures[1].trim().to_string());
    Ok(())
}

#[poem_macros::poem_function]
#[allow(non_snake_case)]
pub fn _handle_new_meme_template_regex(_line: &str, captures: Vec<String>, fixed_fm: &mut dyn PoemFrontMatterTrait) -> Result<(), anyhow::Error> {
    if let Some(description) = fixed_fm.get_pending_meme_description_mut().take() {
        let template = captures[1].trim().to_string();
        fixed_fm.get_memes_mut().push(Meme {
            description,
            template,
            traits: None,
            nft_id: None,
            lore: None,
            numerology: None,
        });
    } else {
        eprintln!("Warning: Template found without a preceding description for new meme format.");
    }
    Ok(())
}
