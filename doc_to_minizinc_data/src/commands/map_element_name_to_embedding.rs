use crate::prelude::*;
use std::collections::HashMap;
use std::fs::File;
use std::path::PathBuf;
use parquet::arrow::arrow_reader::ParquetRecordBatchReaderBuilder;
use arrow::array::{Array, StringArray};
use doc_to_minizinc_data::embedding_lookup::EmbeddingLookup;
use std::io::Write;

pub fn handle_map_element_name_to_embedding_command(
    input_parquet_file: PathBuf,
    output_mapping_file: PathBuf,
) -> Result<()> {
    println!("Mapping element names to embeddings...");
    println!("Input Parquet file: {:?}", input_parquet_file);
    println!("Output mapping file: {:?}", output_mapping_file);

    // 1. Load word embeddings (from the 'new' dataset generated by doc_to_minizinc_data)
    let embeddings_parquet_path = PathBuf::from("datasets/old_dataset/word_embeddings.parquet"); // Hardcoded for now
    let embeddings_file = File::open(&embeddings_parquet_path)?;
    let embeddings_builder = ParquetRecordBatchReaderBuilder::try_new(embeddings_file)?;
    let embeddings_reader = embeddings_builder.build()?;

    let mut id_to_word: HashMap<u32, String> = HashMap::new();
    let mut embeddings_map: HashMap<u32, Vec<f64>> = HashMap::new();

    for batch_result in embeddings_reader {
        let record_batch = batch_result?;
        let id_column = record_batch.column_by_name("id").expect("id column not found");
        let word_column = record_batch.column_by_name("word").expect("word column not found");
        let embedding_column = record_batch.column_by_name("embedding").expect("embedding column not found");

        let id_array = id_column.as_any().downcast_ref::<arrow::array::UInt32Array>().expect("id column is not UInt32Array");
        let word_array = word_column.as_any().downcast_ref::<StringArray>().expect("word column is not StringArray");
        let embedding_list_array = embedding_column.as_any().downcast_ref::<arrow::array::ListArray>().expect("embedding column is not ListArray");

        for i in 0..id_array.len() {
            let id = id_array.value(i);
            let word = word_array.value(i).to_string();
            let embedding_values = embedding_list_array.value(i);
            let float_array = embedding_values.as_any().downcast_ref::<arrow::array::Float64Array>().expect("embedding list element is not Float64Array");
            let embedding_vec: Vec<f64> = float_array.values().to_vec();

            id_to_word.insert(id, word);
            embeddings_map.insert(id, embedding_vec);
        }
    }

    let embedding_lookup = EmbeddingLookup::new(&id_to_word, &embeddings_map);

    // 2. Read element names from the input Parquet file
    let input_file = File::open(&input_parquet_file)?;
    let input_builder = ParquetRecordBatchReaderBuilder::try_new(input_file)?;
    let input_reader = input_builder.build()?;

    let mut output_file = File::create(&output_mapping_file)?;

    writeln!(output_file, "element_name,embedding_id,embedding_vector")?;

    for batch_result in input_reader {
        let record_batch = batch_result?;
        let element_name_column = record_batch.column_by_name("element_name").expect("element_name column not found");
        let element_name_array = element_name_column.as_any().downcast_ref::<StringArray>().expect("element_name column is not StringArray");

        for i in 0..element_name_array.len() {
            let element_name = element_name_array.value(i);
            if element_name.is_empty() { continue; }

            if let Some(word_embedding) = embedding_lookup.lookup_embedding(element_name) {
                writeln!(
                    output_file,
                    "{},{},{:?}",
                    element_name,
                    word_embedding.id,
                    word_embedding.embedding
                )?;
            } else {
                writeln!(output_file, "{},,", element_name)?;
            }
        }
    }

    println!("Mapping complete. Results written to {:?}", output_mapping_file);

    Ok(())
}
