% solfunmeme_vial_engine.mzn
% A MiniZinc model representing core concepts from the SOLFUNMEME Vial Engine (Lean4 sketch).

% --- Core Data Structures ---

% A Meme is a list of real numbers in [0,1]
array[int] of float: Meme;

% Provenance structure (simplified for MiniZinc)
record Provenance = {
    int pins, % IPFS pin count
    int gitCommits,
    int gitForks,
    int archiveMirrors,
    int cidAgeDays,
    int contractAgeDays,
    int supplyCap,
    int minted,
    int royaltyBps % 0..10000
};

% Emoji encoding as prime-mapped state
array[int] of string: emojiCodex = [
"ğŸ„", "ğŸŒ¿", "ğŸ§¬", "ğŸ¤–", "ğŸŒ", "ğŸ”", "ğŸ§ ", "ğŸ”®", "ğŸ•‰ï¸", "ğŸ’»",
"ğŸ§ª", "ğŸ“Š", "ğŸ­", "ğŸ“œ", "ğŸš€", "ğŸª", "ğŸŒŒ", "ğŸ”¬", "ğŸ–¥ï¸", "âš¡",
"ğŸ§©", "ğŸ¦¾", "ğŸ”„", "ğŸ“", "ğŸ“ˆ", "ğŸŒŸ", "ğŸ§´", "ğŸ“–", "ğŸ”£", "ğŸ—£ï¸"
];

% Prime codex
array[int] of int: primeCodex = [
2, 3, 5, 7, 11, 13, 17, 19, 23, 29,
31, 37, 41, 43, 47, 53, 59, 61, 67, 71,
73, 79, 83, 89, 97, 101, 103, 107, 109, 113
];

% --- Helper Functions (simplified) ---

% Clamps a real number to the [0,1] interval
function float: clamp01(x: float) = max(0.0, min(1.0, x));

% Computes the mean of a list of real numbers
function float: mean(xs: array[int] of float) = sum(xs) / int2float(card(xs));

% Computes the variance of a list of real numbers (simplified)
function float: variance(xs: array[int] of float) =
    let {
        float_mean = mean(xs)
    } in
    sum(i in index_set(xs)) (pow(xs[i] - float_mean, 2)) / int2float(card(xs));

% --- Traits ---

% Blue Eye: Introspection
function float: traitEb(m: Meme) = clamp01(0.4 * (sum(m) / 20.0));

% Nutrient Exchange Efficiency: Peaks at balanced state
function float: traitNE(m: Meme) =
    let {
        float_sum = sum(m),
        float_len = int2float(card(m))
    } in
    if float_len = 0.0 then 0.0
    else (
        if float_sum <= float_len * 0.5 then clamp01(float_sum / float_len)
        else clamp01((float_len - float_sum) / float_len)
    );

% Secretome Vibe: Peaks at mean state ~0.5
function float: traitSV(m: Meme) = clamp01(0.6 * (1.0 - abs(mean(m) - 0.5)));

% Helper for traitRedundancy
function float: sat(x: float) = x / (1.0 + x);

% Provenance trait: Redundancy
function float: traitRedundancy(p: Provenance) = clamp01(sat(int2float(p.pins + p.archiveMirrors) / 8.0));

array[int] of float: primeWeights = [
    0.000, 0.100, 0.227, 0.311, 0.422, 0.464, 0.530, 0.557, 0.605, 0.663,
    0.680, 0.723, 0.748, 0.760, 0.782, 0.812, 0.838, 0.846, 0.869, 0.883,
    0.890, 0.910, 0.922, 0.939, 0.960, 0.970, 0.975, 0.984, 0.989, 1.000
];

% Stress Tolerance: Higher for low variance, normalized
function float: traitST(m: Meme) = clamp01(1.0 - (variance(m) / 0.25));

% Signaling Intensity
function float: traitSI(m: Meme) = 
    let { 
        float_len = int2float(card(m)) 
    } in 
    if float_len = 0.0 then 0.0 
    else clamp01(sum(m) / float_len);

% Autoregulation
function float: traitAR(m: Meme) = 
    let { 
        max_val = if card(m) = 0 then 0.0 else max(m) 
    } in 
    if max_val <= 0.8 then 0.7 else 0.3;

% Arbuscule Density
function float: traitAD(m: Meme) = 
    let { 
        float_sum = sum(m),
        float_len = int2float(card(m)) 
    } in 
    if float_len = 0.0 then 0.0 
    else clamp01(0.8 * (float_sum / (float_len * 2.0)));

% Secretome Complexity: Proportion of high-intensity signals
function float: traitSC(m: Meme) = 
    let { 
        float_len = int2float(card(m)),
        high_signals = sum(i in index_set(m)) (if m[i] >= 0.5 then 1.0 else 0.0) 
    } in 
    if float_len = 0.0 then 0.0 
    else clamp01(0.7 * (high_signals / float_len));

% Secretome Utterance: Rewards uniform signaling
function float: traitSU(m: Meme) = 
    let { 
        float_len = int2float(card(m)),
        abs_diff_sum = sum(i in index_set(m)) (abs(m[i] - 0.5)) 
    } in 
    if float_len = 0.0 then 0.0 
    else clamp01(0.8 * (1.0 - (abs_diff_sum / float_len)));

% Secretome Resonance: Amplifies minimal state
function float: traitSR(m: Meme) = 
    let { 
        min_val = if card(m) = 0 then 1.0 else min(m) 
    } in 
    clamp01(0.9 * min_val);

% Provenance trait: Code Lineage
function float: traitCodeLineage(p: Provenance) = clamp01(sat(int2float(p.gitCommits) * 0.01 + int2float(p.gitForks) * 0.05));

% Provenance trait: Longevity
function float: traitLongevity(p: Provenance) = clamp01(sat(int2float(p.cidAgeDays) / 90.0 + int2float(p.contractAgeDays) / 365.0));

% Helper for traitScarcity
function float: normRatio(num: int, den: int) = 
    if den = 0 then 0.0 else clamp01(int2float(num) / int2float(den));

% Provenance trait: Scarcity
function float: traitScarcity(p: Provenance) = 
    let { 
        demand = normRatio(p.minted, max(1, p.supplyCap)) 
    } in 
    clamp01(1.0 - demand);

% Provenance trait: Royalty
function float: traitRoyalty(p: Provenance) = clamp01(1.0 - (int2float(p.royaltyBps) / 10000.0));

% --- Evolution Operator Functions ---

% Blend with secretome-aware bias
function float: blendValue(v1: float, v2: float, secretomeFactor: float) =
    clamp01(v1 * (0.4 * (1.0 - secretomeFactor)) + v2 * (0.6 * (1.0 + secretomeFactor)));

% Prime-mapped trait (pTrait i m)
function float: pTrait(i: int, m: Meme) =
    let {
        w = if i >= 1 and i <= card(primeWeights) then primeWeights[i] else 0.5,
        mu = mean(m),
        mu_prime = if card(m) = 0 then 0.0
                   else (if (i-1) mod 3 = 0 then mu % 0-indexed for mod
                         else (if (i-1) mod 3 = 1 then max(m)
                               else min(m)))
    } in
    clamp01(0.5 * w + 0.5 * mu_prime);

% One transform step with secretome + web/NFT modulation
function array[int] of float: transformStep(m: Meme, p: Provenance) =
    let {
        % Pull secretome fields
        sSV = traitSV(m),
        sSC = traitSC(m),
        sSU = traitSU(m),
        sSR = traitSR(m),
        secretomeFactor = (sSV + sSC + sSU + sSR) / 4.0,

        % Biological supports
        nutrientBoost = traitNE(m),
        stressResist = traitST(m),
        signalFactor = traitSI(m),
        regulation = traitAR(m),
        arbuscule = traitAD(m),

        % Web/NFT modulation
        redun = traitRedundancy(p),
        code = traitCodeLineage(p),
        life = traitLongevity(p),
        scarce = traitScarcity(p),
        royal = traitRoyalty(p),

        infra = (redun + code + life) / 3.0,
        market = (scarce + royal) / 2.0
    } in
    [
        clamp01(
            blendValue(m[i], mean(m), secretomeFactor) *
            (1.0 + 0.2 * nutrientBoost + 0.2 * stressResist + 0.1 * arbuscule) *
            clamp01(signalFactor + 0.3 * sSU) *
            clamp01(regulation + 0.2 * sSR) *
            clamp01(0.7 + 0.2 * infra + 0.1 * market)
        )
        | i in index_set(m)
    ];

% --- Solve and Output ---
solve satisfy;

output [
    "--- SOLFUNMEME Vial Engine Concepts ---\n",
    "Emoji Codex: ", show(emojiCodex), "\n",
    "Prime Codex: ", show(primeCodex), "\n"
];